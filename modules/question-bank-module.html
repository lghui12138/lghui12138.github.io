<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>❓ 题库练习 - 流体力学海洋</title>
    
    <!-- Font Awesome - 使用国内CDN -->
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        /* ===== 海洋主题变量 ===== */
        :root {
            --ocean-blue: #006994;
            --ocean-light: #4facfe;
            --ocean-deep: #003d5b;
            --coral: #ff6b6b;
            --seafoam: #00f2fe;
            --sand: #f4d03f;
            --wave-blue: #3498db;
            --bg-ocean: linear-gradient(135deg, #006994 0%, #4facfe 25%, #00f2fe 50%, #006994 75%, #003d5b 100%);
            --text-light: #ffffff;
            --text-dark: #2c3e50;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-ocean);
            background-size: 400% 400%;
            animation: ocean-wave 15s ease-in-out infinite;
            color: var(--text-light);
            min-height: 100vh;
        }
        
        @keyframes ocean-wave {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        /* ===== 海洋背景 ===== */
        .ocean-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }
        
        .wave {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 100px;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120" preserveAspectRatio="none"><path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V0Z" opacity=".25" fill="%2300f2fe"/><path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V0Z" opacity=".5" fill="%234facfe"/><path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V0Z" fill="%23006994"/></svg>') repeat-x;
            animation: wave-move 20s linear infinite;
        }
        
        .wave:nth-child(2) {
            animation-delay: -5s;
            opacity: 0.7;
        }
        
        .wave:nth-child(3) {
            animation-delay: -10s;
            opacity: 0.5;
        }
        
        @keyframes wave-move {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* ===== 导航栏 ===== */
        .nav-bar {
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 3px solid var(--ocean-light);
            padding: 15px 0;
            backdrop-filter: blur(20px);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        
        .nav-brand {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--ocean-blue);
            text-decoration: none;
        }
        
        .nav-brand i {
            font-size: 2rem;
            animation: ocean-pulse 2s ease-in-out infinite;
        }
        
        @keyframes ocean-pulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 10px var(--ocean-light)); }
            50% { transform: scale(1.1); filter: drop-shadow(0 0 20px var(--seafoam)); }
        }
        
        .btn-back {
            background: linear-gradient(45deg, var(--ocean-light), var(--seafoam));
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-back:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
        
        /* ===== 主内容 ===== */
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .page-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .page-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--text-light);
        }
        
        .page-subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* ===== 统计卡片 ===== */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid var(--ocean-light);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            color: var(--text-dark);
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border-color: var(--coral);
        }
        
        .stat-icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: var(--ocean-blue);
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--ocean-blue);
        }
        
        .stat-label {
            font-size: 1rem;
            color: var(--text-dark);
        }
        
        /* ===== 题库控制 ===== */
        .question-controls {
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid var(--ocean-light);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            color: var(--text-dark);
        }
        
        .control-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn-control {
            background: linear-gradient(45deg, var(--ocean-light), var(--seafoam));
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-control:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
        
        .btn-control.secondary {
            background: linear-gradient(45deg, var(--coral), #ff8e8e);
        }
        
        /* ===== 题目显示区域 ===== */
        .question-container {
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid var(--ocean-light);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            color: var(--text-dark);
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .question-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1000;
            border-radius: 0;
            margin: 0;
            padding: 60px 40px 40px;
        }
        
        .fullscreen-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1001;
        }
        
        .fullscreen-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--ocean-light);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .fullscreen-btn:hover {
            background: var(--ocean-light);
            color: white;
            transform: scale(1.1);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--ocean-light);
        }
        
        .question-title {
            font-size: 1.8rem;
            color: var(--ocean-blue);
            font-weight: bold;
        }
        
        .question-progress {
            color: var(--ocean-blue);
            font-weight: 600;
        }
        
        .question-text {
            font-size: 1.3rem;
            margin-bottom: 30px;
            line-height: 1.6;
            color: var(--text-dark);
        }
        
        .options-list {
            display: grid;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .option-item {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid var(--ocean-light);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .option-item:hover {
            background: var(--ocean-light);
            color: white;
            transform: translateX(10px);
        }
        
        .option-item.selected {
            background: var(--coral);
            color: white;
            border-color: var(--coral);
        }
        
        .option-letter {
            background: rgba(255, 255, 255, 0.2);
            color: inherit;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .question-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid var(--ocean-light);
        }
        
        .timer {
            color: var(--ocean-blue);
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        /* ===== AI出题区域 ===== */
        .ai-section {
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid var(--ocean-light);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            color: var(--text-dark);
        }
        
        .ai-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .ai-icon {
            font-size: 2rem;
            color: var(--ocean-blue);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .ai-input {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .ai-input input {
            flex: 1;
            padding: 15px;
            border: 2px solid var(--ocean-light);
            border-radius: 15px;
            font-size: 16px;
        }
        
        .ai-input input:focus {
            outline: none;
            border-color: var(--coral);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }
        
        .ai-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .ai-options {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ai-options label {
            font-weight: 600;
            color: var(--ocean-blue);
        }
        
        .ai-options select {
            padding: 8px 12px;
            border: 2px solid var(--ocean-light);
            border-radius: 10px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }
        
        .ai-buttons {
            display: flex;
            gap: 10px;
        }
        
        .ai-tips {
            background: rgba(79, 172, 254, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .tip-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 0.9em;
            color: var(--ocean-blue);
        }
        
        .tip-item:last-child {
            margin-bottom: 0;
        }
        
        .tip-item i {
            color: var(--coral);
            width: 16px;
        }
        
        /* ===== 通知系统 ===== */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--ocean-light);
            border-radius: 15px;
            padding: 20px;
            color: var(--text-dark);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 350px;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            border-color: #27ae60;
            background: rgba(39, 174, 96, 0.1);
        }
        
        .notification.error {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }
        
        /* ===== 错题本和收藏功能样式 ===== */
        .special-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .special-section {
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid var(--ocean-light);
            border-radius: 20px;
            padding: 30px;
            color: var(--text-dark);
            transition: all 0.3s ease;
        }
        
        .special-section:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.2);
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--ocean-light);
        }
        
        .section-icon {
            font-size: 2rem;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(45deg, var(--ocean-light), var(--seafoam));
            border-radius: 50%;
            color: white;
        }
        
        .section-header h3 {
            font-size: 1.5rem;
            color: var(--text-dark);
            margin: 0;
        }
        
        .section-header p {
            font-size: 0.9rem;
            color: #666;
            margin: 5px 0 0 0;
        }
        
        .section-content {
            min-height: 200px;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 10px;
        }
        
        .empty-state small {
            font-size: 0.9rem;
            opacity: 0.7;
        }
        
        .section-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        .wrong-questions-list,
        .favorites-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 10px;
            padding: 15px;
            background: #f9f9f9;
        }
        
        .question-item {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        .question-item:hover {
            border-color: var(--ocean-light);
            box-shadow: 0 2px 8px rgba(79, 172, 254, 0.1);
        }
        
        .question-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .question-type {
            background: var(--ocean-light);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }
        
        .question-actions {
            display: flex;
            gap: 5px;
        }
        
        .action-btn {
            background: none;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .action-btn:hover {
            background: var(--ocean-light);
            color: white;
            border-color: var(--ocean-light);
        }
        
        .action-btn.favorite {
            color: #ff6b6b;
        }
        
        .action-btn.favorite.active {
            background: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
        }
        
        /* ===== 响应式设计 ===== */
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            .question-header {
                flex-direction: column;
                gap: 15px;
            }
            
            .question-footer {
                flex-direction: column;
                gap: 15px;
            }
            
            .special-sections {
                grid-template-columns: 1fr;
            }
        }
        
        /* ===== 推荐题目样式 ===== */
        .recommendation-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }
        
        .recommendation-section h3 {
            color: var(--ocean-light);
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        .recommended-list {
            display: grid;
            gap: 15px;
        }
        
        .recommended-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .recommended-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .item-number {
            background: var(--ocean-light);
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .item-difficulty {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
        }
        
        .item-difficulty.easy {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }
        
        .item-difficulty.medium {
            background: rgba(241, 196, 15, 0.2);
            color: #f1c40f;
        }
        
        .item-difficulty.hard {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }
        
        .item-content {
            font-size: 0.9rem;
            line-height: 1.4;
            margin-bottom: 8px;
            color: var(--text-light);
        }
        
        .item-category {
            font-size: 0.8rem;
            color: var(--ocean-light);
            opacity: 0.8;
        }
        
        /* ===== 移动端适配 ===== */
        @media (max-width: 768px) {
            .recommendation-section {
                padding: 15px;
                margin: 15px 0;
            }
            
            .recommendation-section h3 {
                font-size: 1.1rem;
            }
            
            .recommended-item {
                padding: 12px;
            }
            
            .item-content {
                font-size: 0.85rem;
            }
            
            .item-difficulty {
                font-size: 0.65rem;
                padding: 3px 6px;
            }
        }
        
        /* ===== 全屏题目查看样式 ===== */
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        .fullscreen-question {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            background: linear-gradient(135deg, #006994 0%, #4facfe 100%);
            border-radius: 20px;
            padding: 30px;
            color: white;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .fullscreen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .fullscreen-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--ocean-light);
        }
        
        .fullscreen-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }
        
        .fullscreen-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .fullscreen-question-content {
            font-size: 1.2rem;
            line-height: 1.6;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border-left: 4px solid var(--ocean-light);
        }
        
        .fullscreen-options {
            display: grid;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .fullscreen-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .fullscreen-option:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--ocean-light);
            transform: translateX(5px);
        }
        
        .fullscreen-option.selected {
            background: rgba(79, 172, 254, 0.3);
            border-color: var(--ocean-light);
        }
        
        .fullscreen-option.correct {
            background: rgba(46, 204, 113, 0.3);
            border-color: #2ecc71;
        }
        
        .fullscreen-option.wrong {
            background: rgba(231, 76, 60, 0.3);
            border-color: #e74c3c;
        }
        
        .option-label {
            background: var(--ocean-light);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .fullscreen-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .nav-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .question-progress {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: var(--ocean-light);
        }
        
        .fullscreen-explanation {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #f39c12;
            display: none;
        }
        
        .explanation-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .explanation-content {
            font-size: 1rem;
            line-height: 1.5;
        }
        
        .fullscreen-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .action-btn {
            flex: 1;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .action-btn.primary {
            background: var(--ocean-light);
        }
        
        .action-btn.primary:hover {
            background: var(--ocean-blue);
        }
        
        .action-btn.secondary {
            background: rgba(241, 196, 15, 0.3);
            color: #f1c40f;
        }
        
        .action-btn.secondary:hover {
            background: rgba(241, 196, 15, 0.4);
        }
        
        /* ===== 移动端全屏适配 ===== */
        @media (max-width: 768px) {
            .fullscreen-question {
                width: 95%;
                padding: 20px;
                max-height: 95vh;
            }
            
            .fullscreen-title {
                font-size: 1.2rem;
            }
            
            .fullscreen-question-content {
                font-size: 1rem;
                padding: 15px;
            }
            
            .fullscreen-option {
                padding: 12px 15px;
                font-size: 0.9rem;
            }
            
            .option-label {
                width: 25px;
                height: 25px;
                font-size: 0.8rem;
            }
            
            .nav-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .action-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .fullscreen-navigation {
                flex-direction: column;
                gap: 10px;
            }
            
            .fullscreen-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- 海洋背景 -->
    <div class="ocean-bg">
        <div class="wave"></div>
        <div class="wave"></div>
        <div class="wave"></div>
    </div>
    
    <!-- 导航栏 -->
    <nav class="nav-bar">
        <div class="nav-container">
            <a href="#" class="nav-brand">
                <i class="fas fa-question-circle"></i>
                <span>❓ 题库练习</span>
            </a>
            <a href="../index-modular.html" class="btn-back">
                <i class="fas fa-arrow-left"></i>
                返回主页
            </a>
        </div>
    </nav>
    
    <!-- 主内容 -->
    <div class="main-content">
        <div class="page-header">
            <h1 class="page-title">❓ 流体力学题库练习</h1>
            <p class="page-subtitle">全面的题库系统，助您掌握流体力学知识</p>
        </div>
        
        <!-- 统计卡片 -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-icon">📚</div>
                <div class="stat-value" id="totalQuestions">150</div>
                <div class="stat-label">总题数</div>
            </div>
            <div class="stat-card">
                <div class="stat-icon">✅</div>
                <div class="stat-value" id="answeredQuestions">0</div>
                <div class="stat-label">已答题</div>
            </div>
            <div class="stat-card">
                <div class="stat-icon">🎯</div>
                <div class="stat-value" id="correctRate">0%</div>
                <div class="stat-label">正确率</div>
            </div>
            <div class="stat-card">
                <div class="stat-icon">⏱️</div>
                <div class="stat-value" id="avgTime">0s</div>
                <div class="stat-label">平均用时</div>
            </div>
        </div>
        
        <!-- AI出题区域 -->
        <div class="ai-section">
            <div class="ai-header">
                <div class="ai-icon">🤖</div>
                <h2>AI智能出题</h2>
                <p style="font-size: 0.9em; opacity: 0.8; margin-top: 5px;">使用SiliconFlow AI生成专业流体力学题目</p>
            </div>
            <div class="ai-input">
                <input type="text" id="aiTopic" placeholder="请输入出题主题，例如：伯努利方程、雷诺数、边界层理论等">
                <div class="ai-controls">
                    <div class="ai-options">
                        <label for="aiQuestionCount">题目数量:</label>
                        <select id="aiQuestionCount">
                            <option value="1">1道</option>
                            <option value="3">3道</option>
                            <option value="5" selected>5道</option>
                            <option value="8">8道</option>
                            <option value="10">10道</option>
                        </select>
                    </div>
                    <div class="ai-buttons">
                        <button class="btn-control" onclick="generateAIQuestion()">
                            <i class="fas fa-magic"></i> 单题生成
                        </button>
                        <button class="btn-control primary" onclick="generateBatchAIQuestions()">
                            <i class="fas fa-layer-group"></i> 批量生成
                        </button>
                        <button class="btn-control secondary" onclick="testAIConnection()">
                            <i class="fas fa-wifi"></i> 测试连接
                        </button>
                    </div>
                </div>
            </div>
            <div class="ai-tips">
                <div class="tip-item">
                    <i class="fas fa-lightbulb"></i>
                    <span>支持的主题：伯努利方程、雷诺数、边界层理论、流体粘性、压力损失等</span>
                </div>
                <div class="tip-item">
                    <i class="fas fa-clock"></i>
                    <span>生成时间：单题约2-3秒，批量生成会有进度提示</span>
                </div>
                <div class="tip-item">
                    <i class="fas fa-shield-alt"></i>
                    <span>备用机制：如果AI生成失败，会自动使用本地备用题目</span>
                </div>
            </div>
            <div id="aiQuestionResult" style="display: none;">
                <!-- AI生成的题目将显示在这里 -->
            </div>
        </div>
        
        <!-- 推荐题目 -->
        <div id="recommendedQuestions" class="recommendation-section" style="display: none;">
            <!-- 推荐题目将在这里动态生成 -->
        </div>
        
        <!-- 错题本和收藏功能 -->
        <div class="special-sections">
            <!-- 错题本 -->
            <div class="special-section" id="wrongQuestionsSection">
                <div class="section-header">
                    <div class="section-icon">⚠️</div>
                    <h3>错题本</h3>
                    <p>记录您做错的题目，重点复习</p>
                </div>
                <div class="section-content">
                    <div class="wrong-questions-list" id="wrongQuestionsList">
                        <div class="empty-state">
                            <i class="fas fa-clipboard-list"></i>
                            <p>暂无错题记录</p>
                            <small>开始练习后，做错的题目会自动添加到错题本</small>
                        </div>
                    </div>
                    <div class="section-actions">
                        <button class="btn-control secondary" onclick="practiceWrongQuestions()">
                            <i class="fas fa-redo"></i> 练习错题
                        </button>
                        <button class="btn-control" onclick="clearWrongQuestions()">
                            <i class="fas fa-trash"></i> 清空错题本
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 收藏题目 -->
            <div class="special-section" id="favoritesSection">
                <div class="section-header">
                    <div class="section-icon">❤️</div>
                    <h3>收藏题目</h3>
                    <p>收藏重要的题目，方便复习</p>
                </div>
                <div class="section-content">
                    <div class="favorites-list" id="favoritesList">
                        <div class="empty-state">
                            <i class="fas fa-heart"></i>
                            <p>暂无收藏题目</p>
                            <small>点击题目旁的❤️按钮可以收藏题目</small>
                        </div>
                    </div>
                    <div class="section-actions">
                        <button class="btn-control secondary" onclick="practiceFavorites()">
                            <i class="fas fa-play"></i> 练习收藏
                        </button>
                        <button class="btn-control" onclick="exportFavorites()">
                            <i class="fas fa-download"></i> 导出收藏
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 题库控制 -->
        <div class="question-controls">
            <div class="control-buttons">
                <button class="btn-control" onclick="startPractice()">
                    <i class="fas fa-play"></i> 开始练习
                </button>
                <button class="btn-control" onclick="previousQuestion()">
                    <i class="fas fa-chevron-left"></i> 上一题
                </button>
                <button class="btn-control" onclick="nextQuestion()">
                    下一题 <i class="fas fa-chevron-right"></i>
                </button>
                <button class="btn-control secondary" onclick="submitAnswer()">
                    <i class="fas fa-check"></i> 提交答案
                </button>
                <button class="btn-control" onclick="showExplanation()">
                    <i class="fas fa-lightbulb"></i> 查看解析
                </button>
                <button class="btn-control" onclick="resetPractice()">
                    <i class="fas fa-redo"></i> 重新开始
                </button>
            </div>
        </div>
        
        <!-- 题目显示区域 -->
        <div class="question-container" id="questionContainer">
            <div style="text-align: center; color: var(--ocean-blue);">
                <div style="font-size: 4rem; margin-bottom: 20px;">🌊</div>
                <h2>欢迎来到题库练习</h2>
                <p>点击"开始练习"按钮开始答题</p>
            </div>
        </div>
        
        <!-- 全屏题目查看 -->
        <div class="fullscreen-overlay" id="fullscreenOverlay">
            <div class="fullscreen-question">
                <div class="fullscreen-header">
                    <div class="fullscreen-title">题目详情</div>
                    <button class="fullscreen-close" onclick="closeFullscreen()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="fullscreen-navigation">
                    <button class="nav-btn" onclick="previousFullscreenQuestion()" id="prevFullscreenBtn">
                        <i class="fas fa-chevron-left"></i> 上一题
                    </button>
                    <div class="question-progress" id="fullscreenProgress">
                        第 1 题 / 共 0 题
                    </div>
                    <button class="nav-btn" onclick="nextFullscreenQuestion()" id="nextFullscreenBtn">
                        下一题 <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                
                <div class="fullscreen-question-content" id="fullscreenQuestionContent">
                    <!-- 题目内容将在这里显示 -->
                </div>
                
                <div class="fullscreen-options" id="fullscreenOptions">
                    <!-- 选项将在这里显示 -->
                </div>
                
                <div class="fullscreen-explanation" id="fullscreenExplanation">
                    <div class="explanation-title">
                        <i class="fas fa-lightbulb"></i> 题目解析
                    </div>
                    <div class="explanation-content" id="fullscreenExplanationContent">
                        <!-- 解析内容将在这里显示 -->
                    </div>
                </div>
                
                <div class="fullscreen-actions">
                    <button class="action-btn secondary" onclick="toggleFullscreenExplanation()" id="explanationBtn">
                        <i class="fas fa-lightbulb"></i> 查看解析
                    </button>
                    <button class="action-btn primary" onclick="submitFullscreenAnswer()" id="submitFullscreenBtn">
                        <i class="fas fa-check"></i> 提交答案
                    </button>
                    <button class="action-btn" onclick="toggleFullscreenFavorite()" id="favoriteFullscreenBtn">
                        <i class="fas fa-heart"></i> 收藏题目
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 通知容器 -->
    <div id="notification-container"></div>
    
    <script>
        // 完整的题库数据
        const questionsData = [
            // 流体力学易错名词及概念汇总题目
            {
                id: 1001,
                text: "🔬 亥姆霍兹速度分析定理中，M点速度由哪三部分组成？",
                options: [
                    "平动速度、转动速度、变形速度",
                    "平动速度、转动速度、粘性速度",
                    "平动速度、转动速度、压力速度",
                    "平动速度、转动速度、重力速度"
                ],
                correct: 0,
                explanation: "亥姆霍兹速度分析定理指出，M点速度是与Mo点相同的平动速度V(Mo)、绕Mo点转动在M点引起的速度及因流体变形在M点引起的速度三者之和。",
                category: "流体动力学",
                difficulty: "困难",
                tags: ["亥姆霍兹", "速度分析", "定理"]
            },
            {
                id: 1002,
                text: "📊 本构方程中，应力张量等于哪三个张量之和？",
                options: [
                    "静压张量、粘性应力张量、体积变化应力张量",
                    "静压张量、惯性应力张量、重力应力张量",
                    "静压张量、弹性应力张量、塑性应力张量",
                    "静压张量、表面张力张量、粘性应力张量"
                ],
                correct: 0,
                explanation: "本构方程：应力（张量）＝静压（张量）＋纯剪切流动引起粘性应力（张量）＋体积变化引起的应力（张量）。",
                category: "流体动力学",
                difficulty: "困难",
                tags: ["本构方程", "应力张量", "粘性"]
            },
            {
                id: 1003,
                text: "⚡ 运动方程（动量方程）中，流体微团加速度等于哪些力的合力？",
                options: [
                    "体积力、压强梯度力、粘性力",
                    "重力、浮力、阻力",
                    "惯性力、离心力、科氏力",
                    "表面张力、粘性力、压力"
                ],
                correct: 0,
                explanation: "运动方程（动量方程）：流体微团加速度＝单位体积上受到体积力＋压强梯度力＋粘性力。",
                category: "流体动力学",
                difficulty: "困难",
                tags: ["运动方程", "动量方程", "流体微团"]
            },
            {
                id: 1004,
                text: "🌊 尼古拉兹曲线中，层流区的特点是？",
                options: [
                    "粗糙管和光滑管阻力系数相同",
                    "粗糙管阻力系数大于光滑管",
                    "粗糙管阻力系数小于光滑管",
                    "阻力系数与粗糙度无关"
                ],
                correct: 0,
                explanation: "尼古拉兹曲线层流区：粗糙管和光滑管阻力系数相同，只与雷诺数有关。",
                category: "流体动力学",
                difficulty: "中等",
                tags: ["尼古拉兹曲线", "层流", "阻力系数"]
            },
            {
                id: 1005,
                text: "🌊 尼古拉兹曲线中，紊流粗糙区（阻力平方区）的特点是什么？",
                options: [
                    "只与相对粗糙度k/d有关，且为一常数",
                    "只与雷诺数有关",
                    "与雷诺数和相对粗糙度都有关",
                    "与流速和管径有关"
                ],
                correct: 0,
                explanation: "紊流粗糙区（阻力平方区）：只与k/d有关，且为一常数（基本上）。",
                category: "流体动力学",
                difficulty: "中等",
                tags: ["尼古拉兹曲线", "紊流", "阻力平方区"]
            },
            {
                id: 1006,
                text: "🌊 小振幅波浪运动中，若为驻波，流体质点轨迹是什么？",
                options: [
                    "直线",
                    "圆周",
                    "椭圆",
                    "抛物线"
                ],
                correct: 0,
                explanation: "若为驻波，流体质点轨迹是直线，在节点处作水平振动，在波峰、波谷处作垂直振动。",
                category: "波浪理论",
                difficulty: "中等",
                tags: ["波浪运动", "驻波", "质点轨迹"]
            },
            {
                id: 1007,
                text: "🌊 小振幅波浪运动中，若为前进波，流体质点运动轨迹是什么？",
                options: [
                    "近似圆周运动（或椭圆运动）",
                    "直线运动",
                    "抛物线运动",
                    "螺旋运动"
                ],
                correct: 0,
                explanation: "若为前进波，流体质点近似作圆周运动（或椭圆运动），愈往下质点运动半径愈小。",
                category: "波浪理论",
                difficulty: "中等",
                tags: ["波浪运动", "前进波", "质点轨迹"]
            },
            {
                id: 1008,
                text: "📊 应变率张量S描述的是什么？",
                options: [
                    "流体变形运动（角变形率、线相对增长率）",
                    "流体旋转运动",
                    "流体平移运动",
                    "流体压缩运动"
                ],
                correct: 0,
                explanation: "应变率张量：描述流体变形运动（角变形率、线相对增长率）的二阶张量，用S表示。",
                category: "流体动力学",
                difficulty: "困难",
                tags: ["应变率张量", "流体变形", "二阶张量"]
            },
            {
                id: 1009,
                text: "🔬 雷诺实验揭示了流动的哪两种状态？",
                options: [
                    "层流和湍流",
                    "定常流和非定常流",
                    "可压缩流和不可压缩流",
                    "有旋流和无旋流"
                ],
                correct: 0,
                explanation: "雷诺实验：流动分为层流、湍流两种。层流流线层次分明，湍流流动流体质点运动杂乱无章。",
                category: "流体动力学",
                difficulty: "中等",
                tags: ["雷诺实验", "层流", "湍流"]
            },
            {
                id: 1010,
                text: "🌍 Rossby数表征的是什么之比？",
                options: [
                    "惯性力和科氏力之比",
                    "粘性力和惯性力之比",
                    "重力和浮力之比",
                    "压力和粘性力之比"
                ],
                correct: 0,
                explanation: "Rossby数：表征惯性力和科氏力之比，是衡量科氏力效应（旋转效应）的重要参数。",
                category: "地球流体力学",
                difficulty: "困难",
                tags: ["Rossby数", "惯性力", "科氏力"]
            },
            {
                id: 1011,
                text: "🌊 层流的特点是什么？",
                options: [
                    "流动有明晰流线，严格分层，层与层之间有剪切流动，没有法向混合",
                    "流动没有明晰流线，不分层，流体团之间混合明显",
                    "流动有明晰流线，但层与层之间有混合",
                    "流动没有流线，但有分层"
                ],
                correct: 0,
                explanation: "层流：流动有明晰流线，严格分层，层与层之间有剪切流动，没有法向混合。",
                category: "流体动力学",
                difficulty: "中等",
                tags: ["层流", "流线", "分层流动"]
            },
            {
                id: 1012,
                text: "🌊 湍流的特点是什么？",
                options: [
                    "流动没有明晰流线，不分层，流体团之间混合明显，存在无规则脉动",
                    "流动有明晰流线，严格分层，没有混合",
                    "流动有明晰流线，但有混合",
                    "流动没有流线，但有分层"
                ],
                correct: 0,
                explanation: "湍流：流动没有明晰流线，不分层，流体团之间混合明显；流动除了沿大方向整体运动，还存在无规则脉动。",
                category: "流体动力学",
                difficulty: "中等",
                tags: ["湍流", "脉动", "混合"]
            },
            {
                id: 1013,
                text: "📐 Prandtl混合长理论中，混合长Lm的物理意义是什么？",
                options: [
                    "流体微团移动这个尺度距离后才能与其他流体微团发生混合",
                    "流体微团的平均自由程",
                    "流体微团的直径",
                    "流体微团的运动距离"
                ],
                correct: 0,
                explanation: "Prandtl混合长理论：借鉴'分子自由程'的概念，假设湍流中的流体微团有'混合长'，流体微团只有移动了这个尺度距离后才能与其他流体微团发生混合。",
                category: "湍流理论",
                difficulty: "困难",
                tags: ["Prandtl", "混合长理论", "湍流"]
            },
            {
                id: 1014,
                text: "🔬 边界层理论的基本思想是什么？",
                options: [
                    "在边界附近分出一薄层，以内按粘性流体处理，以外按理想流体处理",
                    "在边界附近分出一薄层，全部按粘性流体处理",
                    "在边界附近分出一薄层，全部按理想流体处理",
                    "在边界附近分出一薄层，按可压缩流体处理"
                ],
                correct: 0,
                explanation: "边界层理论：在研究大Re数、无流动分离的绕流问题时，一般在边界附近分出一薄层，以薄层边界为界，以内按照粘性流体处理，以外按照理想流体绕流处理。",
                category: "边界层理论",
                difficulty: "困难",
                tags: ["边界层", "粘性流体", "理想流体"]
            },
            {
                id: 1015,
                text: "📊 边界层厚度的人为规定是什么？",
                options: [
                    "与外部流动速度相差1%的地方为边界层上界",
                    "与外部流动速度相差5%的地方为边界层上界",
                    "与外部流动速度相差10%的地方为边界层上界",
                    "与外部流动速度相差50%的地方为边界层上界"
                ],
                correct: 0,
                explanation: "边界层理论中，一般人为的规定与外部流动速度相差1%的地方为边界层上界。",
                category: "边界层理论",
                difficulty: "中等",
                tags: ["边界层", "厚度", "速度分布"]
            },
            {
                id: 1016,
                text: "🌊 湍流运动的四个基本特性不包括以下哪项？",
                options: [
                    "稳定性",
                    "随机性",
                    "混合性",
                    "有旋性",
                    "耗散性"
                ],
                correct: 0,
                explanation: "湍流运动基本特性：随机性（不规则随机运动）、混合性（高效混合）、有旋性（不同尺度三维涡旋）、耗散性（湍流耗散更多能量）。",
                category: "湍流理论",
                difficulty: "中等",
                tags: ["湍流", "基本特性", "随机性"]
            },
            {
                id: 1017,
                text: "📐 Bernoulli方程的适用条件不包括以下哪项？",
                options: [
                    "理想流体",
                    "正压流体",
                    "体积力有势",
                    "定常流动",
                    "有旋流动"
                ],
                correct: 4,
                explanation: "Bernoulli方程：在满足理想正压体积力有势流体定常流动情况下，同一条流线上各点单位质量上机械能相等。",
                category: "流体动力学",
                difficulty: "中等",
                tags: ["Bernoulli方程", "理想流体", "定常流动"]
            },
            {
                id: 1018,
                text: "🔬 牛顿流体的定义是什么？",
                options: [
                    "应力张量P与应变率张量S之间的关系满足广义牛顿公式的流体",
                    "粘性系数为常数的流体",
                    "密度为常数的流体",
                    "不可压缩的流体"
                ],
                correct: 0,
                explanation: "牛顿流体：应力张量P与应变率张量S之间的关系满足广义牛顿公式的流体称为牛顿流体。否则称为非牛顿流体。",
                category: "流体性质",
                difficulty: "中等",
                tags: ["牛顿流体", "应力张量", "应变率张量"]
            },
            {
                id: 1019,
                text: "🌊 开尔文定理的适用条件是什么？",
                options: [
                    "理想正压流体，且外力有势",
                    "理想不可压缩流体",
                    "粘性流体",
                    "可压缩流体"
                ],
                correct: 0,
                explanation: "开尔文定理表明如果我们考虑的是理想正压流体、且外力有势，则沿任一封闭物质线速度环量和通过任一物质面的涡通量在运动过程中不变。",
                category: "流体动力学",
                difficulty: "困难",
                tags: ["开尔文定理", "理想流体", "涡通量"]
            },
            {
                id: 1020,
                text: "🌊 流线的定义是什么？",
                options: [
                    "同一时刻中流场内速度的连线，线上速度方向即是该点流线的切线方向",
                    "流体质点的运动轨迹",
                    "流体的边界线",
                    "等压线"
                ],
                correct: 0,
                explanation: "流线：同一时刻中流场内速度的连线，线上速度方向即是该点流线的切线方向。",
                category: "流体动力学",
                difficulty: "简单",
                tags: ["流线", "速度场", "切线方向"]
            },
            {
                id: 1021,
                text: "🔬 大Re数为什么引入边界层近似？",
                options: [
                    "在物面附近定会有一薄层，其内部粘性力惯性力同等重要",
                    "为了简化计算",
                    "为了忽略粘性效应",
                    "为了考虑压缩性"
                ],
                correct: 0,
                explanation: "在物面附近定会有一薄层，其内部流体速度沿物面切向分量，由外部理想流体流动速度迅速减小至物面处切向速度为零。该层内不满足雷诺数远大于1的条件，而是粘性力惯性力同等重要。",
                category: "边界层理论",
                difficulty: "困难",
                tags: ["边界层", "雷诺数", "粘性力"]
            },
            {
                id: 1022,
                text: "📊 雷诺应力的特点是什么？",
                options: [
                    "产生于湍流脉动，代表脉动对于平均流的作用，不是真实的力",
                    "产生于流体微团之间的相对运动，是一种真实的力",
                    "产生于压力梯度，是一种真实的力",
                    "产生于重力，是一种真实的力"
                ],
                correct: 0,
                explanation: "雷诺应力：雷诺应力产生于湍流脉动，代表脉动对于平均流的作用，一般粘性应力则是产生于流体微团之间的相对运动，是一种真实的力，雷诺应力不是真实的力。",
                category: "湍流理论",
                difficulty: "困难",
                tags: ["雷诺应力", "湍流脉动", "平均流"]
            },
            {
                id: 1023,
                text: "🌊 流体易流动性的含义是什么？",
                options: [
                    "流体静止时只有法向应力，没有切向应力",
                    "流体可以自由流动",
                    "流体没有粘性",
                    "流体不可压缩"
                ],
                correct: 0,
                explanation: "流体易流动性：流体静止时只有法向应力，没有切向应力。",
                category: "流体性质",
                difficulty: "简单",
                tags: ["易流动性", "法向应力", "切向应力"]
            },
            {
                id: 1024,
                text: "🔬 连续介质假设的适用条件是什么？",
                options: [
                    "流体运动尺度远大于分子平均自由程",
                    "流体运动尺度远小于分子平均自由程",
                    "流体运动尺度等于分子平均自由程",
                    "流体运动尺度与分子平均自由程无关"
                ],
                correct: 0,
                explanation: "连续介质假设：液体是由不连续的分子/原子构成的，但在流体运动尺度远大于分子平均自由程时，可将流体看成连续的流体微团。",
                category: "流体性质",
                difficulty: "中等",
                tags: ["连续介质", "分子自由程", "流体微团"]
            },
            {
                id: 1025,
                text: "📐 几何相似的定义是什么？",
                options: [
                    "流场中被绕流物体和流场中各对应在线元之间夹角相等，且对应长度成比例",
                    "流场中速度分布相同",
                    "流场中压力分布相同",
                    "流场中温度分布相同"
                ],
                correct: 0,
                explanation: "几何相似：指流场中被绕流物体和流场中各对应在线元之间夹角相等，且对应长度成比例。",
                category: "相似理论",
                difficulty: "中等",
                tags: ["几何相似", "夹角相等", "长度成比例"]
            },
            {
                id: 1026,
                text: "🌊 速度散度∇·v的物理意义是什么？",
                options: [
                    "流体微团体积相对变化率",
                    "流体微团角速度",
                    "流体微团线速度",
                    "流体微团加速度"
                ],
                correct: 0,
                explanation: "速度散度：∇·v，是流体微团体积相对变化率，等于流体微团沿坐标轴相对伸长率之和，若∇·v=0，则流体不可压，有流函数。",
                category: "流体动力学",
                difficulty: "困难",
                tags: ["速度散度", "体积变化率", "不可压"]
            },
            {
                id: 1027,
                text: "🌊 速度旋度∇×v的物理意义是什么？",
                options: [
                    "流体微团自转角速度2ω",
                    "流体微团线速度",
                    "流体微团体积变化率",
                    "流体微团加速度"
                ],
                correct: 0,
                explanation: "速度旋度：∇×v，是流体微团自转角速度2ω，若∇×v=0，则流体无旋，有速度势。",
                category: "流体动力学",
                difficulty: "困难",
                tags: ["速度旋度", "自转角速度", "无旋"]
            },
            {
                id: 1028,
                text: "📐 复位势中镜像方法的基本思想是什么？",
                options: [
                    "在边界外放置一组奇点，使组合流场恰好存在边界流线",
                    "在边界内放置一组奇点",
                    "在边界上放置一组奇点",
                    "在流场中心放置一组奇点"
                ],
                correct: 0,
                explanation: "镜像方法基本思想：设想以C为边界区域的τ'之外存在一组流体力学上奇点S'，如在τ'内放置一组奇点S之后，组合流场恰好存在这样一条流线，它就是边界C。",
                category: "复变函数",
                difficulty: "困难",
                tags: ["镜像方法", "奇点", "边界流线"]
            },
            {
                id: 1029,
                text: "🌊 球形液滴下落均匀定常速度公式中，速度与半径的关系是？",
                options: [
                    "速度与半径的平方成正比",
                    "速度与半径成正比",
                    "速度与半径的平方根成正比",
                    "速度与半径无关"
                ],
                correct: 0,
                explanation: "球形液滴下落均匀定常速度：v = (2/9)(ρ-ρ')ga²/μ，其中a是半径，速度与半径的平方成正比。",
                category: "流体动力学",
                difficulty: "中等",
                tags: ["球形液滴", "下落速度", "半径"]
            },
            {
                id: 1030,
                text: "📊 平板边界层厚度与哪些因素有关？",
                options: [
                    "流体粘性系数、流体在平板上位置、来流速度",
                    "流体密度、流体温度、来流速度",
                    "流体压力、流体温度、来流速度",
                    "流体粘度、流体压力、来流速度"
                ],
                correct: 0,
                explanation: "平板边界层厚度：δ = k√(νx/U)，k为常数，故边界层厚度与流体粘性系数、流体在平板上位置、来流速度有关。",
                category: "边界层理论",
                difficulty: "中等",
                tags: ["边界层厚度", "粘性系数", "来流速度"]
            },
            {
                id: 1,
                text: "🌊 在静止流体中，压强的传递遵循什么定律？",
                options: [
                    "帕斯卡定律",
                    "阿基米德定律", 
                    "胡克定律",
                    "牛顿定律"
                ],
                correct: 0,
                explanation: "帕斯卡定律指出，在静止流体中，压强能够等值地传递到流体的各个部分。",
                category: "流体静力学",
                difficulty: "简单"
            },
            {
                id: 2,
                text: "📐 流体静力学基本方程dp = -ρg dz中，负号表示什么物理意义？",
                options: [
                    "压强随高度增加而减小",
                    "压强随高度增加而增大",
                    "密度为负值",
                    "重力加速度向下"
                ],
                correct: 0,
                explanation: "负号表示压强随高度增加而减小，这是因为重力的作用。",
                category: "流体静力学",
                difficulty: "简单"
            },
            {
                id: 3,
                text: "⚖️ 阿基米德定律描述的是什么现象？",
                options: [
                    "浮力等于排开液体的重力",
                    "浮力等于物体的重力",
                    "浮力等于液体的重力",
                    "浮力等于物体的体积"
                ],
                correct: 0,
                explanation: "阿基米德定律指出，浸在液体中的物体受到向上的浮力，浮力的大小等于物体排开液体的重力。",
                category: "流体静力学",
                difficulty: "简单"
            },
            {
                id: 4,
                text: "🔬 在静止流体中，等压面是什么形状？",
                options: [
                    "水平面",
                    "垂直面",
                    "斜面",
                    "任意曲面"
                ],
                correct: 0,
                explanation: "在重力场中，静止流体的等压面是水平面，这是因为重力只影响垂直方向的压强分布。",
                category: "流体静力学",
                difficulty: "简单"
            },
            {
                id: 5,
                text: "📊 流体静力学中，绝对压强与表压强的关系是？",
                options: [
                    "绝对压强 = 表压强 + 大气压强",
                    "绝对压强 = 表压强 - 大气压强",
                    "绝对压强 = 表压强",
                    "绝对压强 = 大气压强 - 表压强"
                ],
                correct: 0,
                explanation: "绝对压强是相对于真空的压强，表压强是相对于大气压的压强，两者关系为绝对压强 = 表压强 + 大气压强。",
                category: "流体静力学",
                difficulty: "简单"
            },
            {
                id: 6,
                text: "🌊 伯努利方程的适用条件不包括以下哪项？",
                options: [
                    "定常流动",
                    "无粘性流体",
                    "不可压缩流体",
                    "有旋流动"
                ],
                correct: 3,
                explanation: "伯努利方程适用于定常、无粘性、不可压缩的无旋流动。",
                category: "流体动力学",
                difficulty: "中等"
            },
            {
                id: 7,
                text: "📐 伯努利方程中，动能项的形式是？",
                options: [
                    "ρv²/2",
                    "ρv²",
                    "ρv/2",
                    "ρv"
                ],
                correct: 0,
                explanation: "伯努利方程中的动能项为ρv²/2，表示单位体积流体的动能。",
                category: "流体动力学",
                difficulty: "中等"
            },
            {
                id: 8,
                text: "🧪 在文丘里管中，流速最大的位置是？",
                options: [
                    "入口处",
                    "喉部",
                    "出口处",
                    "中间位置"
                ],
                correct: 1,
                explanation: "根据连续性方程，在文丘里管的喉部，截面积最小，流速最大。",
                category: "流体动力学",
                difficulty: "中等"
            },
            {
                id: 9,
                text: "📊 皮托管测量的是什么？",
                options: [
                    "静压",
                    "动压",
                    "总压",
                    "差压"
                ],
                correct: 2,
                explanation: "皮托管测量的是总压，即静压与动压之和。",
                category: "测量仪器",
                difficulty: "中等"
            },
            {
                id: 10,
                text: "⚖️ 伯努利方程中的势能项是？",
                options: [
                    "ρgz",
                    "ρg",
                    "gz",
                    "ρz"
                ],
                correct: 0,
                explanation: "伯努利方程中的势能项为ρgz，表示单位体积流体的重力势能。",
                category: "流体动力学",
                difficulty: "中等"
            },
            {
                id: 11,
                text: "🔬 边界层的定义是什么？",
                options: [
                    "流体与固体壁面接触的区域",
                    "流速梯度很大的薄层",
                    "粘性效应显著的薄层",
                    "以上都是"
                ],
                correct: 3,
                explanation: "边界层是流体与固体壁面接触的区域，是流速梯度很大、粘性效应显著的薄层。",
                category: "边界层理论",
                difficulty: "困难"
            },
            {
                id: 12,
                text: "📐 普朗特边界层理论的基本假设不包括？",
                options: [
                    "边界层很薄",
                    "边界层内粘性力与惯性力同量级",
                    "边界层外为无粘流动",
                    "边界层内压力沿法向不变"
                ],
                correct: 1,
                explanation: "普朗特边界层理论假设边界层内粘性力与惯性力同量级，这是边界层理论的核心。",
                category: "边界层理论",
                difficulty: "困难"
            },
            {
                id: 13,
                text: "🌊 边界层分离的条件是？",
                options: [
                    "壁面切应力为零",
                    "壁面切应力为负",
                    "壁面切应力为正",
                    "壁面切应力无穷大"
                ],
                correct: 0,
                explanation: "边界层分离的条件是壁面切应力为零，即∂u/∂y|y=0 = 0。",
                category: "边界层理论",
                difficulty: "困难"
            },
            {
                id: 14,
                text: "📊 边界层厚度δ的定义是？",
                options: [
                    "流速达到主流速度99%的距离",
                    "流速达到主流速度90%的距离",
                    "流速达到主流速度95%的距离",
                    "流速达到主流速度50%的距离"
                ],
                correct: 0,
                explanation: "边界层厚度δ定义为流速达到主流速度99%的距离。",
                category: "边界层理论",
                difficulty: "困难"
            },
            {
                id: 15,
                text: "⚖️ 平板边界层中，位移厚度δ*的物理意义是？",
                options: [
                    "边界层的实际厚度",
                    "由于粘性效应造成的流量损失",
                    "由于粘性效应造成的动量损失",
                    "边界层的能量损失"
                ],
                correct: 1,
                explanation: "位移厚度δ*表示由于粘性效应造成的流量损失，即无粘流动中流量减少的等效厚度。",
                category: "边界层理论",
                difficulty: "困难"
            }
        ];
        
        // 练习状态
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let practiceStarted = false;
        let startTime = null;
        let questionTimes = [];
        let quizSystem = null;
        
        // 错题本和收藏功能
        function showWrongQuestions() {
            if (quizSystem) {
                quizSystem.updateWrongQuestionsDisplay();
            }
        }
        
        function practiceWrongQuestions() {
            if (!quizSystem || quizSystem.wrongQuestions.length === 0) {
                showNotification('错题本为空，无法开始练习', 'error');
                return;
            }
            startQuizWithQuestions(quizSystem.wrongQuestions);
        }
        
        function clearWrongQuestions() {
            if (quizSystem) {
                quizSystem.clearWrongQuestions();
            }
        }
        
        function showFavorites() {
            if (quizSystem) {
                quizSystem.updateFavoritesDisplay();
            }
        }
        
        function practiceFavorites() {
            if (!quizSystem || quizSystem.favoriteQuestions.length === 0) {
                showNotification('收藏夹为空，无法开始练习', 'error');
                return;
            }
            startQuizWithQuestions(quizSystem.favoriteQuestions);
        }
        
        function exportFavorites() {
            if (!quizSystem || quizSystem.favoriteQuestions.length === 0) {
                showNotification('收藏夹为空，无法导出', 'error');
                return;
            }
            
            const data = {
                favorites: quizSystem.favoriteQuestions,
                exportTime: new Date().toISOString(),
                totalCount: quizSystem.favoriteQuestions.length
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `收藏题目_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('收藏题目导出成功', 'success');
        }
        
        // 使用指定题目开始练习
        function startQuizWithQuestions(questions) {
            if (questions.length === 0) {
                showNotification('没有可用的题目', 'error');
                return;
            }
            
            currentQuestionIndex = 0;
            userAnswers = [];
            startTime = new Date();
            practiceStarted = true;
            
            // 显示第一题
            displayQuestionWithData(questions[0]);
            
            showNotification(`开始练习 ${questions.length} 道题目`, 'success');
        }
        
        // 显示指定题目数据
        function displayQuestionWithData(question) {
            const container = document.getElementById('questionContainer');
            
            container.innerHTML = `
                <div class="fullscreen-controls">
                    <button class="fullscreen-btn" onclick="toggleFullscreen()" title="全屏模式">
                        <i class="fas fa-expand" id="fullscreenIcon"></i>
                    </button>
                    <button class="fullscreen-btn" onclick="closeFullscreen()" title="关闭全屏" style="display: none;" id="closeFullscreenBtn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="question-header">
                    <div class="question-title">第 ${currentQuestionIndex + 1} 题</div>
                    <div class="question-progress">${currentQuestionIndex + 1} / ${questions.length}</div>
                </div>
                
                <div class="question-text">${question.question || question.text}</div>
                
                <div class="options-list">
                    ${(question.options || []).map((option, index) => `
                        <div class="option-item ${userAnswers[currentQuestionIndex] === index ? 'selected' : ''}" 
                             onclick="selectOption(${index})">
                            <div class="option-letter">${String.fromCharCode(65 + index)}</div>
                            <div>${option}</div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="question-actions">
                    <button class="btn-control" onclick="previousQuestion()" id="prevBtn" ${currentQuestionIndex === 0 ? 'disabled' : ''}>
                        <i class="fas fa-chevron-left"></i>
                        上一题
                    </button>
                    <button class="btn-control" onclick="nextQuestion()" id="nextBtn" ${currentQuestionIndex === questions.length - 1 ? 'disabled' : ''}>
                        下一题
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            `;
            
            container.style.display = 'block';
        }
        
        // 显示通知
        function showNotification(message, type = 'info', duration = 3000) {
            const container = document.getElementById('notification-container');
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                ${message}
            `;
            
            container.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);
            
            if (duration > 0) {
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }, duration);
            }
        }
        
        // 更新统计信息
        function updateStats() {
            const answered = userAnswers.filter(answer => answer !== undefined).length;
            const correct = userAnswers.filter((answer, index) => 
                answer === questionsData[index]?.correct
            ).length;
            const rate = answered > 0 ? Math.round((correct / answered) * 100) : 0;
            
            document.getElementById('totalQuestions').textContent = questionsData.length;
            document.getElementById('answeredQuestions').textContent = answered;
            document.getElementById('correctRate').textContent = rate + '%';
            
            const avgTime = questionTimes.length > 0 
                ? Math.round(questionTimes.reduce((a, b) => a + b, 0) / questionTimes.length)
                : 0;
            document.getElementById('avgTime').textContent = avgTime + 's';
        }
        
        // 显示题目
        function displayQuestion() {
            if (!practiceStarted) {
                return;
            }
            
            const question = questionsData[currentQuestionIndex];
            const container = document.getElementById('questionContainer');
            
            container.innerHTML = `
                <div class="fullscreen-controls">
                    <button class="fullscreen-btn" onclick="toggleFullscreen()" title="全屏模式">
                        <i class="fas fa-expand" id="fullscreenIcon"></i>
                    </button>
                    <button class="fullscreen-btn" onclick="closeFullscreen()" title="关闭全屏" style="display: none;" id="closeFullscreenBtn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="question-header">
                    <div class="question-title">第 ${currentQuestionIndex + 1} 题</div>
                    <div class="question-progress">${currentQuestionIndex + 1} / ${questionsData.length}</div>
                </div>
                
                <div class="question-text">${question.text}</div>
                
                <div class="options-list">
                    ${question.options.map((option, index) => `
                        <div class="option-item ${userAnswers[currentQuestionIndex] === index ? 'selected' : ''}" 
                             onclick="selectOption(${index})">
                            <div class="option-letter">${String.fromCharCode(65 + index)}</div>
                            <div>${option}</div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="question-actions">
                    <button class="btn-control" onclick="previousQuestion()" id="prevBtn" ${currentQuestionIndex === 0 ? 'disabled' : ''}>
                        <i class="fas fa-chevron-left"></i>
                        上一题
                    </button>
                    <button class="btn-control" onclick="nextQuestion()" id="nextBtn" ${currentQuestionIndex === questionsData.length - 1 ? 'disabled' : ''}>
                        下一题
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn-control secondary" onclick="showExplanation()" id="explainBtn" style="display: none;">
                        <i class="fas fa-lightbulb"></i>
                        查看解析
                    </button>
                </div>
                
                <!-- 解析区域 -->
                <div class="explanation-area" id="explanationArea" style="display: none; margin-top: 20px; padding: 20px; background: rgba(79, 172, 254, 0.1); border-radius: 15px; border-left: 4px solid var(--ocean-light);">
                    <h4 style="color: var(--ocean-blue); margin-bottom: 10px;">
                        <i class="fas fa-lightbulb"></i> 题目解析
                    </h4>
                    <div id="explanationText"></div>
                </div>
                
                <div class="question-footer">
                    <div class="timer" id="timer">时间: 0s</div>
                    <div>难度: ${question.difficulty} | 分类: ${question.category}</div>
                </div>
            `;
            
            // 开始计时
            startTime = Date.now();
            updateTimer();
        }
        
        // 更新计时器
        function updateTimer() {
            if (!startTime) return;
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                timerElement.textContent = `时间: ${elapsed}s`;
            }
            
            setTimeout(updateTimer, 1000);
        }
        
        // 选择选项
        function selectOption(index) {
            if (!practiceStarted) return;
            
            userAnswers[currentQuestionIndex] = index;
            
            // 更新选项显示
            const options = document.querySelectorAll('.option-item');
            options.forEach((option, i) => {
                option.classList.toggle('selected', i === index);
            });
        }
        
        // 开始练习
        function startPractice() {
            practiceStarted = true;
            currentQuestionIndex = 0;
            userAnswers = [];
            questionTimes = [];
            startTime = Date.now();
            
            displayQuestion();
            showNotification('🎯 练习开始！', 'success');
        }
        
        // 上一题
        function previousQuestion() {
            if (!practiceStarted) {
                showNotification('请先开始练习', 'error');
                return;
            }
            
            if (currentQuestionIndex > 0) {
                // 记录当前题目用时
                if (startTime) {
                    questionTimes[currentQuestionIndex] = Math.floor((Date.now() - startTime) / 1000);
                }
                
                currentQuestionIndex--;
                displayQuestion();
            } else {
                showNotification('已经是第一题了', 'info');
            }
        }
        
        // 下一题
        function nextQuestion() {
            if (!practiceStarted) {
                showNotification('请先开始练习', 'error');
                return;
            }
            
            if (currentQuestionIndex < questionsData.length - 1) {
                // 记录当前题目用时
                if (startTime) {
                    questionTimes[currentQuestionIndex] = Math.floor((Date.now() - startTime) / 1000);
                }
                
                currentQuestionIndex++;
                displayQuestion();
            } else {
                showNotification('已经是最后一题了', 'info');
            }
        }
        
        // 提交答案
        function submitAnswer() {
            if (!practiceStarted) {
                showNotification('请先开始练习', 'error');
                return;
            }
            
            if (userAnswers[currentQuestionIndex] === undefined) {
                showNotification('请选择一个答案', 'error');
                return;
            }
            
            const question = questionsData[currentQuestionIndex];
            const isCorrect = userAnswers[currentQuestionIndex] === question.correct;
            
            // 记录用时
            if (startTime) {
                questionTimes[currentQuestionIndex] = Math.floor((Date.now() - startTime) / 1000);
            }
            
            if (isCorrect) {
                showNotification('🎉 回答正确！', 'success');
            } else {
                showNotification(`❌ 回答错误。正确答案是：${String.fromCharCode(65 + question.correct)}`, 'error');
            }
            
            updateStats();
        }
        
        // 查看解析
        function showExplanation() {
            if (!practiceStarted) {
                showNotification('请先开始练习', 'error');
                return;
            }
            
            const question = questionsData[currentQuestionIndex];
            const explanationArea = document.getElementById('explanationArea');
            const explanationText = document.getElementById('explanationText');
            
            if (explanationArea && explanationText) {
                explanationText.innerHTML = `
                    <p><strong>正确答案：</strong>${String.fromCharCode(65 + question.correct)}. ${question.options[question.correct]}</p>
                    <p><strong>解析：</strong>${question.explanation}</p>
                    <p><strong>你的答案：</strong>${userAnswers[currentQuestionIndex] !== undefined ? 
                        String.fromCharCode(65 + userAnswers[currentQuestionIndex]) + '. ' + question.options[userAnswers[currentQuestionIndex]] : 
                        '未选择'}</p>
                    <p><strong>结果：</strong><span style="color: ${userAnswers[currentQuestionIndex] === question.correct ? 'var(--success)' : 'var(--error)'}; font-weight: bold;">
                        ${userAnswers[currentQuestionIndex] === question.correct ? '✓ 正确' : '✗ 错误'}
                    </span></p>
                `;
                explanationArea.style.display = 'block';
                showNotification('解析已显示', 'info');
            }
        }
        
        // 切换全屏模式
        function toggleFullscreen() {
            const container = document.getElementById('questionContainer');
            const fullscreenIcon = document.getElementById('fullscreenIcon');
            const closeBtn = document.getElementById('closeFullscreenBtn');
            
            if (container.classList.contains('fullscreen')) {
                closeFullscreen();
            } else {
                container.classList.add('fullscreen');
                fullscreenIcon.className = 'fas fa-compress';
                if (closeBtn) closeBtn.style.display = 'flex';
                showNotification('已进入全屏模式', 'success');
            }
        }
        
        // 关闭全屏模式
        function closeFullscreen() {
            const container = document.getElementById('questionContainer');
            const fullscreenIcon = document.getElementById('fullscreenIcon');
            const closeBtn = document.getElementById('closeFullscreenBtn');
            
            container.classList.remove('fullscreen');
            fullscreenIcon.className = 'fas fa-expand';
            if (closeBtn) closeBtn.style.display = 'none';
            showNotification('已退出全屏模式', 'info');
        }
        
        // 重新开始
        function resetPractice() {
            practiceStarted = false;
            currentQuestionIndex = 0;
            userAnswers = [];
            questionTimes = [];
            startTime = null;
            
            const container = document.getElementById('questionContainer');
            container.innerHTML = `
                <div style="text-align: center; color: var(--ocean-blue);">
                    <div style="font-size: 4rem; margin-bottom: 20px;">🌊</div>
                    <h2>欢迎来到题库练习</h2>
                    <p>点击"开始练习"按钮开始答题</p>
                </div>
            `;
            
            updateStats();
            showNotification('🔄 练习已重置', 'success');
        }
        
        // AI出题
        // AI出题功能 - 真正连接到SiliconFlow API
        async function generateAIQuestion() {
            const topic = document.getElementById('aiTopic').value.trim();
            
            if (!topic) {
                showNotification('请输入出题主题', 'error');
                return;
            }
            
            // 显示加载状态
            const generateBtn = document.querySelector('button[onclick="generateAIQuestion()"]');
            const originalText = generateBtn.innerHTML;
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 生成中...';
            generateBtn.disabled = true;
            
            showNotification('🤖 AI正在生成题目，请稍候...', 'info');
            
            try {
                // 获取现有题库内容作为参考
                const existingQuestions = questionsData.filter(q => q.category !== 'AI生成').slice(0, 10);
                const questionExamples = existingQuestions.map(q => ({
                    question: q.text,
                    category: q.category,
                    difficulty: q.difficulty || 'medium'
                }));
                
                // 获取视频学习内容
                const videoData = JSON.parse(localStorage.getItem('videoData') || '[]');
                const videoTopics = videoData.slice(0, 5).map(v => v.title);
                
                // 获取学习笔记内容
                const notesData = JSON.parse(localStorage.getItem('notesData') || '[]');
                const noteTopics = notesData.slice(0, 5).map(n => n.title);
                
                // 构建AI提示词
                const prompt = `请为流体力学课程生成一道关于"${topic}"的选择题。要求：
1. 题目要准确、有教育意义，符合流体力学教学大纲
2. 提供4个选项，其中只有1个正确答案
3. 提供详细的解析，包含相关公式和概念
4. 难度适中，适合大学生学习
5. 题目要有实际应用背景
6. 参考现有的学习内容，确保题目与课程进度一致

现有题库主题：${questionExamples.map(q => q.category).join(', ')}
视频学习主题：${videoTopics.join(', ')}
笔记学习主题：${noteTopics.join(', ')}

请基于这些现有内容拓展开来出题，确保题目与学习进度匹配。

请严格按照以下JSON格式返回，不要包含其他内容：
{
    "question": "题目内容",
    "options": ["选项A", "选项B", "选项C", "选项D"],
    "correct": 0,
    "explanation": "详细解析",
    "difficulty": "easy/medium/hard",
    "category": "题目分类"
}`;

                // 调用SiliconFlow API
                const response = await fetch('https://api.siliconflow.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer sk-dhseqxecuwwotodiskfdgwdjahnbexcgdotkfsovbgajxnis'
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat',
                        messages: [
                            {
                                role: 'system',
                                content: `你是一个专业的流体力学教师，擅长出题和解析。请遵循以下原则：
1. 题目要准确、有教育意义，符合流体力学教学大纲
2. 提供4个选项，其中只有1个正确答案
3. 提供详细的解析，包含相关公式和概念
4. 难度适中，适合大学生学习
5. 题目要有实际应用背景
6. 严格按照要求的JSON格式返回，不要包含其他内容`
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        temperature: 0.7,
                        max_tokens: 1500
                    })
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                const aiResponse = data.choices[0].message.content;
                
                // 解析AI返回的JSON
                let questionData;
                try {
                    // 尝试提取JSON部分
                    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        questionData = JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('无法解析AI返回的JSON');
                    }
                } catch (parseError) {
                    console.error('JSON解析失败:', parseError);
                    // 如果解析失败，使用备用方案
                    questionData = generateFallbackQuestion(topic);
                }

                // 创建新题目
                const newQuestion = {
                    id: `ai_${Date.now()}`,
                    text: `🤖 AI生成题目：${questionData.question}`,
                    options: questionData.options,
                    correct: questionData.correct,
                    explanation: questionData.explanation,
                    category: "AI生成",
                    difficulty: questionData.difficulty || "中等"
                };
                
                questionsData.push(newQuestion);
                
                const resultDiv = document.getElementById('aiQuestionResult');
                resultDiv.style.display = 'block';
                resultDiv.innerHTML = `
                    <div style="background: rgba(79, 172, 254, 0.1); padding: 20px; border-radius: 15px; border-left: 4px solid var(--ocean-light);">
                        <h3>🤖 AI生成的新题目：</h3>
                        <p><strong>${newQuestion.text}</strong></p>
                        <div style="margin: 10px 0;">
                            <strong>选项：</strong>
                            ${newQuestion.options.map((option, index) => 
                                `<div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </div>`
                            ).join('')}
                        </div>
                        <p><strong>解析：</strong> ${newQuestion.explanation}</p>
                        <p style="color: var(--ocean-light); font-weight: bold;">题目已添加到题库中，可以开始练习了！</p>
                    </div>
                `;
                
                showNotification('🤖 AI题目生成成功！', 'success');
                updateStats();
            } catch (error) {
                console.error('AI生成题目失败:', error);
                
                // 根据错误类型显示不同的提示
                let errorMessage = 'AI生成失败，使用备用题目';
                if (error.message.includes('401')) {
                    errorMessage = 'API密钥无效，使用备用题目';
                } else if (error.message.includes('429')) {
                    errorMessage = 'API请求过于频繁，使用备用题目';
                } else if (error.message.includes('500')) {
                    errorMessage = '服务器错误，使用备用题目';
                } else if (error.message.includes('fetch')) {
                    errorMessage = '网络连接失败，使用备用题目';
                }
                
                showNotification(errorMessage, 'warning');
                
                // 使用备用题目
                const fallbackQuestion = generateFallbackQuestion(topic);
                questionsData.push(fallbackQuestion);
                
                // 保存到本地存储
                saveQuestionsToLocalStorage();
                
                const resultDiv = document.getElementById('aiQuestionResult');
                resultDiv.style.display = 'block';
                resultDiv.innerHTML = `
                    <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 15px; border-left: 4px solid #ffc107;">
                        <h3>🤖 备用题目：</h3>
                        <p><strong>${fallbackQuestion.text}</strong></p>
                        <div style="margin: 10px 0;">
                            <strong>选项：</strong>
                            ${fallbackQuestion.options.map((option, index) => 
                                `<div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </div>`
                            ).join('')}
                        </div>
                        <p><strong>解析：</strong> ${fallbackQuestion.explanation}</p>
                        <p style="color: #ffc107; font-weight: bold;">题目已添加到题库中，可以开始练习了！</p>
                    </div>
                `;
                
                updateStats();
            } finally {
                // 恢复按钮状态
                const generateBtn = document.querySelector('button[onclick="generateAIQuestion()"]');
                if (generateBtn) {
                    generateBtn.innerHTML = '<i class="fas fa-magic"></i> 生成AI题目';
                    generateBtn.disabled = false;
                }
            }
        }
        
        // 生成备用题目
        function generateFallbackQuestion(topic) {
            const fallbackQuestions = {
                '伯努利方程': {
                    question: '伯努利方程适用于什么类型的流动？',
                    options: [
                        '理想流体、不可压缩、定常流动',
                        '粘性流体、可压缩、非定常流动',
                        '理想流体、可压缩、定常流动',
                        '粘性流体、不可压缩、非定常流动'
                    ],
                    correct: 0,
                    explanation: '伯努利方程适用于理想流体、不可压缩、定常流动。这是伯努利方程的基本适用条件。',
                    difficulty: 'medium',
                    category: '流体动力学'
                },
                '雷诺数': {
                    question: '雷诺数Re的定义是什么？',
                    options: [
                        'Re = ρVL/μ',
                        'Re = VL/ν',
                        'Re = ρV²L/μ',
                        'Re = V²L/ν'
                    ],
                    correct: 1,
                    explanation: '雷诺数Re = VL/ν，其中V是特征速度，L是特征长度，ν是运动粘度。',
                    difficulty: 'easy',
                    category: '流动特性'
                },
                '边界层': {
                    question: '边界层理论中，边界层厚度随距离如何变化？',
                    options: [
                        '线性增加',
                        '平方根增加',
                        '指数增加',
                        '对数增加'
                    ],
                    correct: 1,
                    explanation: '边界层厚度随距离的平方根增加，即δ ∝ √x。',
                    difficulty: 'hard',
                    category: '边界层理论'
                },
                '流体静力学': {
                    question: '在静止流体中，压强的传递遵循什么定律？',
                    options: [
                        '帕斯卡定律',
                        '阿基米德定律',
                        '胡克定律',
                        '牛顿定律'
                    ],
                    correct: 0,
                    explanation: '帕斯卡定律指出，在静止流体中，压强能够等值地传递到流体的各个部分。',
                    difficulty: 'easy',
                    category: '流体静力学'
                },
                '管道流动': {
                    question: '圆管层流中，速度分布是什么形状？',
                    options: [
                        '抛物线',
                        '直线',
                        '指数曲线',
                        '对数曲线'
                    ],
                    correct: 0,
                    explanation: '圆管层流中，速度分布是抛物线形状，最大速度在管轴处。',
                    difficulty: 'medium',
                    category: '管道流动'
                }
            };
            
            // 根据主题选择备用题目，如果没有匹配的，使用默认题目
            const fallbackQuestion = fallbackQuestions[topic] || fallbackQuestions['伯努利方程'];
            
            return {
                id: `fallback_${Date.now()}`,
                text: `🤖 备用题目：${fallbackQuestion.question}`,
                options: fallbackQuestion.options,
                correct: fallbackQuestion.correct,
                explanation: fallbackQuestion.explanation,
                category: fallbackQuestion.category,
                difficulty: fallbackQuestion.difficulty,
                isFallback: true
            };
        }
        
        // 保存题目到本地存储
        function saveQuestionsToLocalStorage() {
            try {
                localStorage.setItem('questionsData', JSON.stringify(questionsData));
                console.log('题目数据已保存到本地存储');
            } catch (error) {
                console.error('保存题目数据失败:', error);
            }
        }
        
        // 从本地存储加载题目
        function loadQuestionsFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('questionsData');
                if (savedData) {
                    const loadedQuestions = JSON.parse(savedData);
                    questionsData.push(...loadedQuestions);
                    console.log('从本地存储加载了', loadedQuestions.length, '道题目');
                }
            } catch (error) {
                console.error('加载题目数据失败:', error);
            }
        }

        // 批量AI生成题目
        async function generateBatchAIQuestions() {
            const topic = document.getElementById('aiTopic').value.trim();
            const count = parseInt(document.getElementById('aiQuestionCount').value) || 5;
            
            if (!topic) {
                showNotification('请输入出题主题', 'error');
                return;
            }
            
            if (count < 1 || count > 10) {
                showNotification('题目数量应在1-10之间', 'error');
                return;
            }
            
            showNotification(`🤖 AI正在生成${count}道题目...`, 'info');
            
            const resultDiv = document.getElementById('aiQuestionResult');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = '<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> AI正在生成题目...</div>';
            
            const generatedQuestions = [];
            let successCount = 0;
            let failCount = 0;
            
            for (let i = 0; i < count; i++) {
                try {
                    // 获取现有题库内容作为参考
                    const existingQuestions = questionsData.filter(q => q.category !== 'AI生成').slice(0, 10);
                    const questionExamples = existingQuestions.map(q => ({
                        question: q.text,
                        category: q.category,
                        difficulty: q.difficulty || 'medium'
                    }));
                    
                    // 获取视频学习内容
                    const videoData = JSON.parse(localStorage.getItem('videoData') || '[]');
                    const videoTopics = videoData.slice(0, 5).map(v => v.title);
                    
                    // 获取学习笔记内容
                    const notesData = JSON.parse(localStorage.getItem('notesData') || '[]');
                    const noteTopics = notesData.slice(0, 5).map(n => n.title);
                    
                    // 获取用户学习进度
                    const userLearningData = JSON.parse(localStorage.getItem('userLearningData') || '{}');
                    const userProgress = userLearningData.completedQuestions || 0;
                    const userLevel = userProgress < 10 ? 'beginner' : userProgress < 30 ? 'intermediate' : 'advanced';
                    
                    const prompt = `请为流体力学课程生成第${i + 1}道关于"${topic}"的选择题。要求：
1. 题目要准确、有教育意义，与前面题目不重复
2. 提供4个选项，其中只有1个正确答案
3. 提供详细的解析，包含相关公式和概念
4. 根据用户学习水平调整难度：${userLevel === 'beginner' ? '初学者，基础概念为主' : userLevel === 'intermediate' ? '中等水平，包含计算和应用' : '高级水平，复杂应用和综合分析'}
5. 参考现有的学习内容，确保题目与课程进度一致

现有题库主题：${questionExamples.map(q => q.category).join(', ')}
视频学习主题：${videoTopics.join(', ')}
笔记学习主题：${noteTopics.join(', ')}
用户学习进度：${userProgress}题，水平：${userLevel}

请基于这些现有内容拓展开来出题，确保题目与学习进度匹配，并且与前面生成的题目不重复。

请按以下JSON格式返回：
{
    "question": "题目内容",
    "options": ["选项A", "选项B", "选项C", "选项D"],
    "correct": 0,
    "explanation": "详细解析",
    "difficulty": "easy/medium/hard",
    "category": "题目分类",
    "learningPoints": ["知识点1", "知识点2"]
}`;

                    const response = await fetch('https://api.siliconflow.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer sk-dhseqxecuwwotodiskfdgwdjahnbexcgdotkfsovbgajxnis'
                        },
                        body: JSON.stringify({
                            model: 'deepseek-chat',
                            messages: [
                                {
                                    role: 'system',
                                    content: `你是一个专业的流体力学教师，擅长出题和解析。请遵循以下原则：
1. 题目要准确、有教育意义，符合流体力学教学大纲
2. 提供4个选项，其中只有1个正确答案
3. 提供详细的解析，包含相关公式和概念
4. 根据用户水平调整难度
5. 题目要有实际应用背景
6. 严格按照要求的JSON格式返回，不要包含其他内容`
                                },
                                {
                                    role: 'user',
                                    content: prompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 1500
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API请求失败: ${response.status}`);
                    }

                    const data = await response.json();
                    const aiResponse = data.choices[0].message.content;
                    
                    // 解析AI返回的JSON
                    let questionData;
                    try {
                        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            questionData = JSON.parse(jsonMatch[0]);
                        } else {
                            throw new Error('无法解析AI返回的JSON');
                        }
                    } catch (parseError) {
                        console.error('JSON解析失败:', parseError);
                        questionData = generateFallbackQuestion(topic);
                        failCount++;
                    }

                    // 创建新题目
                    const newQuestion = {
                        id: `ai_batch_${Date.now()}_${i}`,
                        text: `🤖 AI生成题目${i + 1}：${questionData.question}`,
                        options: questionData.options,
                        correct: questionData.correct,
                        explanation: questionData.explanation,
                        category: questionData.category || "AI生成",
                        difficulty: questionData.difficulty || "中等",
                        learningPoints: questionData.learningPoints || []
                    };
                    
                    questionsData.push(newQuestion);
                    generatedQuestions.push(newQuestion);
                    successCount++;
                    
                    // 更新进度显示
                    resultDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <i class="fas fa-spinner fa-spin"></i> 
                            正在生成题目... (${i + 1}/${count})
                            <br>
                            <small>成功: ${successCount}, 失败: ${failCount}</small>
                        </div>
                    `;
                    
                } catch (error) {
                    console.error(`AI生成题目${i + 1}失败:`, error);
                    failCount++;
                    
                    // 使用备用题目
                    const fallbackQuestion = generateFallbackQuestion(topic);
                    questionsData.push(fallbackQuestion);
                    generatedQuestions.push(fallbackQuestion);
                }
            }
            
            // 显示生成结果
            resultDiv.innerHTML = `
                <div style="background: rgba(79, 172, 254, 0.1); padding: 20px; border-radius: 15px; border-left: 4px solid var(--ocean-light);">
                    <h3>🤖 AI批量生成完成</h3>
                    <p><strong>成功生成：${successCount}道题目</strong></p>
                    <p><strong>生成失败：${failCount}道题目</strong></p>
                    <div style="margin: 15px 0;">
                        <strong>生成的题目：</strong>
                        ${generatedQuestions.map((q, index) => `
                            <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <strong>题目${index + 1}：</strong> ${q.text.replace(/^🤖 (AI生成题目|备用题目)\d*：/, '')}
                                <br>
                                <small>难度：${q.difficulty} | 分类：${q.category}</small>
                                ${q.learningPoints && q.learningPoints.length > 0 ? 
                                    `<br><small>知识点：${q.learningPoints.join(', ')}</small>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    <p style="color: var(--ocean-light); font-weight: bold;">所有题目已添加到题库中，可以开始练习了！</p>
                </div>
            `;
            
            // 保存到本地存储
            saveQuestionsToLocalStorage();
            updateStats();
            
            showNotification(`🤖 批量生成完成！成功${successCount}道，失败${failCount}道`, 'success');
        }

        // 生成备用题目
        function generateFallbackQuestion(topic) {
            const fallbackQuestions = {
                '伯努利方程': {
                    question: '关于伯努利方程，下列说法正确的是？',
                    options: [
                        '伯努利方程适用于所有流体流动',
                        '伯努利方程只适用于理想流体',
                        '伯努利方程不适用于可压缩流体',
                        '伯努利方程适用于湍流流动'
                    ],
                    correct: 1,
                    explanation: '伯努利方程只适用于理想流体的稳定流动，不适用于粘性流体和湍流。'
                },
                '雷诺数': {
                    question: '雷诺数Re = ρVD/μ中，D代表什么？',
                    options: [
                        '流体密度',
                        '流速',
                        '特征长度',
                        '粘性系数'
                    ],
                    correct: 2,
                    explanation: 'D代表特征长度，通常是管道直径或物体的特征尺寸。'
                },
                '流体粘性': {
                    question: '流体的粘性系数单位是什么？',
                    options: [
                        'N/m²',
                        'Pa·s',
                        'kg/m³',
                        'm/s'
                    ],
                    correct: 1,
                    explanation: '粘性系数的国际单位是帕斯卡·秒(Pa·s)。'
                }
            };

            const question = fallbackQuestions[topic] || {
                question: `关于${topic}，下列说法正确的是？`,
                options: [
                    '选项A：这是一个关于' + topic + '的正确描述',
                    '选项B：这是一个关于' + topic + '的错误描述',
                    '选项C：这是一个关于' + topic + '的部分正确描述',
                    '选项D：这是一个关于' + topic + '的不完整描述'
                ],
                correct: 0,
                explanation: `这是关于${topic}的基础知识题目，建议查阅相关教材获取更详细的信息。`
            };

            return {
                id: `fallback_${Date.now()}`,
                text: `🤖 备用题目：${question.question}`,
                options: question.options,
                correct: question.correct,
                explanation: question.explanation,
                category: "备用题目",
                difficulty: "中等"
            };
        }
        
        // 扩展题库数据 - 从Untitled.txt迁移
        const EXTENDED_EXERCISES_DATA = {
            // 用户错题本
            wrongQuestions: [],
            // 收藏题目
            favoriteQuestions: [],
            // 学习进度
            progress: {
                totalQuestions: 0,
                completedQuestions: 0,
                correctAnswers: 0,
                wrongAnswers: 0,
                averageScore: 0,
                studyTime: 0
            },
            categories: [
                {
                    id: 'fluid-basics',
                    name: '流体力学基础',
                    icon: 'fas fa-tint',
                    color: '#1e6fa8',
                    description: '流体的基本性质和定义',
                    tags: ['流体', '基础', '性质'],
                    questions: [
                        {
                            id: 'fb-001',
                            type: 'choice',
                            difficulty: 'easy',
                            question: '下列哪个不是流体的基本特性？',
                            options: ['连续性', '粘性', '可压缩性', '刚性'],
                            correct: 3,
                            explanation: '刚性是固体的特性，流体具有流动性，不具有刚性。',
                            points: 10,
                            estimated_time: 30
                        },
                        {
                            id: 'fb-002',
                            type: 'choice',
                            difficulty: 'medium',
                            question: '流体的密度定义为：',
                            options: [
                                '质量与体积的比值',
                                '重量与体积的比值',
                                '质量与重量的比值',
                                '体积与质量的比值'
                            ],
                            correct: 0,
                            explanation: '密度是单位体积的质量，即质量与体积的比值。',
                            points: 15,
                            estimated_time: 45
                        },
                        {
                            id: 'fb-003',
                            type: 'fill',
                            difficulty: 'easy',
                            question: '流体的粘性系数的单位是___。',
                            answer: 'Pa·s',
                            explanation: '粘性系数的国际单位是帕斯卡·秒(Pa·s)。',
                            points: 10,
                            estimated_time: 30
                        },
                        {
                            id: 'fb-004',
                            type: 'calculation',
                            difficulty: 'hard',
                            question: '某流体的密度为1000 kg/m³，体积为2 m³，求其质量。',
                            answer: '2000',
                            unit: 'kg',
                            explanation: '质量 = 密度 × 体积 = 1000 kg/m³ × 2 m³ = 2000 kg',
                            points: 20,
                            estimated_time: 60
                        }
                    ]
                },
                {
                    id: 'bernoulli',
                    name: '伯努利方程',
                    icon: 'fas fa-wave-square',
                    color: '#2c9ab7',
                    description: '伯努利方程及其应用',
                    tags: ['伯努利', '方程', '能量'],
                    questions: [
                        {
                            id: 'hd-001',
                            type: 'choice',
                            difficulty: 'medium',
                            question: '伯努利方程适用于：',
                            options: [
                                '理想流体稳定流动',
                                '粘性流体湍流',
                                '可压缩流体',
                                '非稳定流动'
                            ],
                            correct: 0,
                            explanation: '伯努利方程适用于理想流体的稳定流动。',
                            points: 15,
                            estimated_time: 45
                        },
                        {
                            id: 'hd-002',
                            type: 'choice',
                            difficulty: 'hard',
                            question: '连续性方程反映了：',
                            options: [
                                '质量守恒',
                                '能量守恒',
                                '动量守恒',
                                '角动量守恒'
                            ],
                            correct: 0,
                            explanation: '连续性方程反映了质量守恒定律。',
                            points: 20,
                            estimated_time: 60
                        },
                        {
                            id: 'hd-003',
                            type: 'multiple',
                            difficulty: 'medium',
                            question: '伯努利方程包含以下哪些项？',
                            options: [
                                '压力能',
                                '动能',
                                '势能',
                                '内能'
                            ],
                            correct: [0, 1, 2],
                            explanation: '伯努利方程包含压力能、动能和势能三项。',
                            points: 15,
                            estimated_time: 45
                        },
                        {
                            id: 'hd-004',
                            type: 'calculation',
                            difficulty: 'hard',
                            question: '水在管道中流动，管道直径从10cm变为5cm，如果大直径处的流速为2m/s，求小直径处的流速。',
                            answer: '8',
                            unit: 'm/s',
                            explanation: '根据连续性方程：A₁v₁ = A₂v₂，v₂ = (A₁/A₂)v₁ = (πr₁²/πr₂²)v₁ = (5²/2.5²)×2 = 8 m/s',
                            points: 25,
                            estimated_time: 90
                        },
                        {
                            id: 'hd-005',
                            type: 'calculation',
                            difficulty: 'hard',
                            question: '如何计算管道中的压力损失？',
                            solution: '使用达西-魏斯巴赫公式：hf = f(L/D)(v²/2g)',
                            steps: [
                                '确定摩擦系数f',
                                '计算雷诺数Re',
                                '确定管道长度L和直径D',
                                '计算流速v',
                                '代入公式计算压力损失'
                            ],
                            explanation: '管道压力损失主要考虑摩擦损失，使用达西公式计算。',
                            points: 25,
                            estimated_time: 90
                        }
                    ]
                },
                {
                    id: 'turbulence',
                    name: '湍流理论',
                    icon: 'fas fa-wind',
                    color: '#4db8d6',
                    description: '湍流现象和雷诺数',
                    tags: ['湍流', '雷诺数', '层流'],
                    questions: [
                        {
                            id: 'tb-001',
                            type: 'choice',
                            difficulty: 'hard',
                            question: '雷诺数Re = ρVD/μ中，D代表：',
                            options: ['密度', '速度', '特征长度', '粘性系数'],
                            correct: 2,
                            explanation: 'D代表特征长度，通常是管道直径或物体特征尺寸。',
                            points: 20,
                            estimated_time: 60
                        },
                        {
                            id: 'tb-002',
                            type: 'choice',
                            difficulty: 'medium',
                            question: '雷诺数小于2300时，流动为：',
                            options: ['层流', '湍流', '过渡流', '混合流'],
                            correct: 0,
                            explanation: '雷诺数小于2300时为层流，大于4000时为湍流。',
                            points: 15,
                            estimated_time: 45
                        },
                        {
                            id: 'tb-003',
                            type: 'concept',
                            question: '什么是边界层？',
                            solution: '边界层是靠近固体表面的薄层流体，其中粘性效应显著。',
                            details: [
                                '边界层内速度梯度很大',
                                '粘性力与惯性力相当',
                                '边界层厚度随距离增加',
                                '边界层分离会导致阻力增加'
                            ],
                            explanation: '边界层理论是流体力学中的重要概念，解释了粘性流体在固体表面的流动特性。',
                            points: 25,
                            estimated_time: 90
                        }
                    ]
                }
            ]
        };
        
        // 测试AI连接
        async function testAIConnection() {
            showNotification('🔍 正在测试AI连接...', 'info');
            
            try {
                const response = await fetch('https://api.siliconflow.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer sk-dhseqxecuwwotodiskfdgwdjahnbexcgdotkfsofbgajxnis'
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat',
                        messages: [
                            {
                                role: 'user',
                                content: '请回复"连接成功"'
                            }
                        ],
                        temperature: 0.1,
                        max_tokens: 10
                    })
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                const aiResponse = data.choices[0].message.content;
                
                if (aiResponse.includes('连接成功') || aiResponse.includes('成功')) {
                    showNotification('✅ AI连接测试成功！', 'success');
                } else {
                    showNotification('⚠️ AI连接成功，但响应异常', 'warning');
                }
                
            } catch (error) {
                console.error('AI连接测试失败:', error);
                let errorMessage = 'AI连接测试失败';
                if (error.message.includes('401')) {
                    errorMessage = 'API密钥无效，请检查配置';
                } else if (error.message.includes('429')) {
                    errorMessage = 'API请求过于频繁，请稍后再试';
                } else if (error.message.includes('500')) {
                    errorMessage = '服务器错误，请稍后再试';
                } else if (error.message.includes('fetch')) {
                    errorMessage = '网络连接失败，请检查网络';
                }
                showNotification(`❌ ${errorMessage}`, 'error');
            }
        }

        // 高级题库系统
        class AdvancedQuizSystem {
            constructor() {
                this.questionBank = [];
                this.userAnswers = [];
                this.currentQuestion = 0;
                this.wrongQuestions = [];
                this.favoriteQuestions = [];
                this.analytics = {
                    totalQuestions: 0,
                    correctAnswers: 0,
                    timeSpent: 0,
                    categoryPerformance: {}
                };
                this.loadQuestionBank();
                this.loadUserData();
            }
            
            // 加载用户数据（错题本、收藏等）
            loadUserData() {
                try {
                    const userData = localStorage.getItem('questionBankUserData');
                    if (userData) {
                        const data = JSON.parse(userData);
                        this.wrongQuestions = data.wrongQuestions || [];
                        this.favoriteQuestions = data.favoriteQuestions || [];
                        this.analytics = data.analytics || this.analytics;
                    }
                    this.updateWrongQuestionsDisplay();
                    this.updateFavoritesDisplay();
                } catch (error) {
                    console.error('加载用户数据失败:', error);
                }
            }
            
            // 保存用户数据
            saveUserData() {
                try {
                    const userData = {
                        wrongQuestions: this.wrongQuestions,
                        favoriteQuestions: this.favoriteQuestions,
                        analytics: this.analytics
                    };
                    localStorage.setItem('questionBankUserData', JSON.stringify(userData));
                } catch (error) {
                    console.error('保存用户数据失败:', error);
                }
            }
            
            // 添加错题
            addWrongQuestion(question) {
                if (!this.wrongQuestions.find(q => q.id === question.id)) {
                    this.wrongQuestions.push({
                        ...question,
                        wrongTime: new Date().toISOString(),
                        wrongCount: 1
                    });
                    this.saveUserData();
                    this.updateWrongQuestionsDisplay();
                } else {
                    // 增加错误次数
                    const existing = this.wrongQuestions.find(q => q.id === question.id);
                    existing.wrongCount++;
                    existing.wrongTime = new Date().toISOString();
                    this.saveUserData();
                    this.updateWrongQuestionsDisplay();
                }
            }
            
            // 移除错题
            removeWrongQuestion(questionId) {
                this.wrongQuestions = this.wrongQuestions.filter(q => q.id !== questionId);
                this.saveUserData();
                this.updateWrongQuestionsDisplay();
            }
            
            // 清空错题本
            clearWrongQuestions() {
                if (confirm('确定要清空错题本吗？此操作不可恢复！')) {
                    this.wrongQuestions = [];
                    this.saveUserData();
                    this.updateWrongQuestionsDisplay();
                    showNotification('错题本已清空', 'success');
                }
            }
            
            // 添加收藏
            toggleFavorite(question) {
                const index = this.favoriteQuestions.findIndex(q => q.id === question.id);
                if (index === -1) {
                    this.favoriteQuestions.push({
                        ...question,
                        favoriteTime: new Date().toISOString()
                    });
                    showNotification('题目已收藏', 'success');
                } else {
                    this.favoriteQuestions.splice(index, 1);
                    showNotification('已取消收藏', 'success');
                }
                this.saveUserData();
                this.updateFavoritesDisplay();
            }
            
            // 更新错题本显示
            updateWrongQuestionsDisplay() {
                const container = document.getElementById('wrongQuestionsList');
                if (!container) return;
                
                if (this.wrongQuestions.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-clipboard-list"></i>
                            <p>暂无错题记录</p>
                            <small>开始练习后，做错的题目会自动添加到错题本</small>
                        </div>
                    `;
                } else {
                    container.innerHTML = this.wrongQuestions.map(question => `
                        <div class="question-item">
                            <div class="question-item-header">
                                <span class="question-type">${question.type || '选择题'}</span>
                                <div class="question-actions">
                                    <button class="action-btn" onclick="quizSystem.removeWrongQuestion('${question.id}')" title="移除">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="question-text">${question.question || question.text}</div>
                            <div class="question-meta">
                                <small>错误次数: ${question.wrongCount || 1}</small>
                                <small>最后错误: ${new Date(question.wrongTime).toLocaleDateString()}</small>
                            </div>
                        </div>
                    `).join('');
                }
            }
            
            // 更新收藏显示
            updateFavoritesDisplay() {
                const container = document.getElementById('favoritesList');
                if (!container) return;
                
                if (this.favoriteQuestions.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-heart"></i>
                            <p>暂无收藏题目</p>
                            <small>点击题目旁的❤️按钮可以收藏题目</small>
                        </div>
                    `;
                } else {
                    container.innerHTML = this.favoriteQuestions.map(question => `
                        <div class="question-item">
                            <div class="question-item-header">
                                <span class="question-type">${question.type || '选择题'}</span>
                                <div class="question-actions">
                                    <button class="action-btn favorite active" onclick="quizSystem.toggleFavorite(${JSON.stringify(question)})" title="取消收藏">
                                        <i class="fas fa-heart"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="question-text">${question.question || question.text}</div>
                            <div class="question-meta">
                                <small>收藏时间: ${new Date(question.favoriteTime).toLocaleDateString()}</small>
                            </div>
                        </div>
                    `).join('');
                }
            }

            // 加载题库数据
            async loadQuestionBank() {
                try {
                    // 合并默认题库和扩展题库
                    this.questionBank = [
                        ...questionsData,
                        ...EXTENDED_EXERCISES_DATA.categories.flatMap(cat => cat.questions)
                    ];
                    console.log('题库加载完成:', this.questionBank.length, '道题目');
                } catch (error) {
                    console.error('题库加载失败:', error);
                    this.questionBank = this.getDefaultQuestions();
                }
            }

            // 智能选题算法
            intelligentSelection(questions, count) {
                if (questions.length <= count) return questions;

                // 按难度分布
                const easy = questions.filter(q => q.difficulty === 'easy');
                const medium = questions.filter(q => q.difficulty === 'medium');
                const hard = questions.filter(q => q.difficulty === 'hard');

                // 智能分配比例 (40% 初级, 40% 中级, 20% 高级)
                const easyCount = Math.min(Math.ceil(count * 0.4), easy.length);
                const mediumCount = Math.min(Math.ceil(count * 0.4), medium.length);
                const hardCount = Math.min(count - easyCount - mediumCount, hard.length);

                const selected = [
                    ...this.shuffleArray(easy).slice(0, easyCount),
                    ...this.shuffleArray(medium).slice(0, mediumCount),
                    ...this.shuffleArray(hard).slice(0, hardCount)
                ];

                return this.shuffleArray(selected);
            }

            // 分析难度分布
            analyzeDifficulty(questions) {
                const distribution = { 'easy': 0, 'medium': 0, 'hard': 0 };
                questions.forEach(q => distribution[q.difficulty]++);
                return distribution;
            }

            // 题目推荐系统
            recommendQuestions(userId, currentQuestion) {
                // 基于内容的推荐
                const contentRecommendations = this.getContentBasedRecommendations(currentQuestion);
                
                // 基于协同过滤的推荐
                const collaborativeRecommendations = this.getCollaborativeRecommendations(userId);
                
                return [...contentRecommendations, ...collaborativeRecommendations];
            }

            // 基于内容的推荐
            getContentBasedRecommendations(currentQuestion) {
                if (!currentQuestion) return [];

                return this.questionBank.filter(q => {
                    if (q.id === currentQuestion.id) return false;

                    // 相同类别
                    if (q.category === currentQuestion.category) return true;

                    // 相关标签
                    if (q.tags && currentQuestion.tags &&
                        q.tags.some(tag => currentQuestion.tags.includes(tag))) return true;

                    return false;
                }).slice(0, 5);
            }

            // 基于协同过滤的推荐
            getCollaborativeRecommendations(userId) {
                // 这里可以实现基于用户行为的推荐算法
                return this.questionBank.filter(q => q.difficulty === 'medium').slice(0, 3);
            }

            // 评估答案结果
            evaluateAnswer(questionId, userAnswer, timeSpent) {
                const question = this.questionBank.find(q => q.id === questionId);
                if (!question) return null;

                const isCorrect = userAnswer === question.correct;
                const result = {
                    questionId,
                    userAnswer,
                    correctAnswer: question.correct,
                    isCorrect,
                    timeSpent,
                    points: isCorrect ? question.points : 0,
                    explanation: question.explanation,
                    category: question.category,
                    difficulty: question.difficulty
                };

                this.updateAnalytics(result);
                return result;
            }

            // 更新统计数据
            updateAnalytics(result) {
                this.analytics.totalQuestions++;
                if (result.isCorrect) {
                    this.analytics.correctAnswers++;
                }
                this.analytics.timeSpent += result.timeSpent;

                // 更新分类表现
                if (result.category) {
                    if (!this.analytics.categoryPerformance[result.category]) {
                        this.analytics.categoryPerformance[result.category] = {
                            total: 0,
                            correct: 0
                        };
                    }
                    this.analytics.categoryPerformance[result.category].total++;
                    if (result.isCorrect) {
                        this.analytics.categoryPerformance[result.category].correct++;
                    }
                }
            }

            // 生成学习报告
            generateReport() {
                const accuracy = this.analytics.totalQuestions > 0 ?
                    (this.analytics.correctAnswers / this.analytics.totalQuestions) * 100 : 0;

                const avgTimePerQuestion = this.analytics.totalQuestions > 0 ?
                    this.analytics.timeSpent / this.analytics.totalQuestions : 0;

                const categoryAnalysis = Object.entries(this.analytics.categoryPerformance)
                    .map(([category, data]) => ({
                        category,
                        accuracy: (data.correct / data.total) * 100,
                        total: data.total
                    }))
                    .sort((a, b) => a.accuracy - b.accuracy);

                return {
                    totalQuestions: this.analytics.totalQuestions,
                    correctAnswers: this.analytics.correctAnswers,
                    accuracy: accuracy.toFixed(1),
                    avgTimePerQuestion: Math.round(avgTimePerQuestion),
                    categoryAnalysis,
                    recommendations: this.generateRecommendations(categoryAnalysis)
                };
            }

            // 生成学习建议
            generateRecommendations(categoryAnalysis) {
                const recommendations = [];

                // 如果题目数量不足，建议多做练习
                if (this.analytics.totalQuestions < 20) {
                    recommendations.push({
                        type: 'suggestion',
                        title: '增加练习量',
                        content: '建议多做练习，至少完成20道题目以获得准确的学习评估。'
                    });
                }

                // 针对薄弱环节给出建议
                categoryAnalysis.forEach(category => {
                    if (category.accuracy < 60) {
                        recommendations.push({
                            type: 'weakness',
                            title: `${category.category}需要加强`,
                            content: `在${category.category}方面的正确率较低(${category.accuracy.toFixed(1)}%)，建议重点复习相关内容。`
                        });
                    }
                });

                return recommendations;
            }

            // 工具方法
            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        }

        // 初始化高级题库系统
        const advancedQuizSystem = new AdvancedQuizSystem();
        
        // 性能监控系统
        const PerformanceMonitor = {
            metrics: {
                pageLoad: {},
                userInteractions: [],
                resourceTiming: [],
                errors: []
            },
            observers: [],

            init() {
                this.setupPerformanceObservers();
                this.setupErrorTracking();
                this.startPeriodicReporting();
                console.log('性能监控系统已初始化');
            },

            setupPerformanceObservers() {
                // 页面加载性能
                window.addEventListener('load', () => {
                    setTimeout(() => {
                        this.measurePageLoadPerformance();
                    }, 0);
                });

                // 用户交互性能
                this.observeUserInteractions();

                // 资源加载性能
                this.observeResourceTiming();

                // 长任务监控
                this.observeLongTasks();
            },

            measurePageLoadPerformance() {
                const navigation = performance.getEntriesByType('navigation')[0];
                const paint = performance.getEntriesByType('paint');

                this.metrics.pageLoad = {
                    timestamp: new Date().toISOString(),
                    domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
                    loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
                    firstPaint: paint.find(p => p.name === 'first-paint')?.startTime || 0,
                    firstContentfulPaint: paint.find(p => p.name === 'first-contentful-paint')?.startTime || 0,
                    totalLoadTime: navigation.loadEventEnd - navigation.fetchStart,
                    url: window.location.href
                };

                console.log('页面加载性能:', this.metrics.pageLoad);
            },

            observeUserInteractions() {
                let interactionStart = 0;
                let isInteracting = false;

                const events = ['mousedown', 'keydown', 'touchstart'];

                events.forEach(eventType => {
                    document.addEventListener(eventType, (e) => {
                        if (!isInteracting) {
                            interactionStart = performance.now();
                            isInteracting = true;
                        }
                    }, { passive: true });

                    document.addEventListener(eventType.replace('start', 'end'), (e) => {
                        if (isInteracting) {
                            const interactionTime = performance.now() - interactionStart;

                            this.metrics.userInteractions.push({
                                type: eventType,
                                duration: interactionTime,
                                timestamp: new Date().toISOString(),
                                target: e.target.tagName + (e.target.id ? '#' + e.target.id : '')
                            });

                            isInteracting = false;
                        }
                    }, { passive: true });
                });
            },

            observeResourceTiming() {
                const observer = new PerformanceObserver((list) => {
                    list.getEntries().forEach(entry => {
                        if (entry.initiatorType === 'img' || entry.initiatorType === 'script' || entry.initiatorType === 'css') {
                            this.metrics.resourceTiming.push({
                                name: entry.name,
                                type: entry.initiatorType,
                                duration: entry.duration,
                                size: entry.transferSize || 0,
                                timestamp: new Date().toISOString()
                            });
                        }
                    });
                });

                observer.observe({ entryTypes: ['resource'] });
            },

            observeLongTasks() {
                const observer = new PerformanceObserver((list) => {
                    list.getEntries().forEach(entry => {
                        if (entry.duration > 50) { // 超过50ms的任务
                            this.metrics.userInteractions.push({
                                type: 'long_task',
                                duration: entry.duration,
                                timestamp: new Date().toISOString(),
                                startTime: entry.startTime
                            });
                        }
                    });
                });

                observer.observe({ entryTypes: ['longtask'] });
            },

            setupErrorTracking() {
                // JavaScript错误
                window.addEventListener('error', (e) => {
                    this.metrics.errors.push({
                        type: 'javascript_error',
                        message: e.message,
                        filename: e.filename,
                        lineno: e.lineno,
                        colno: e.colno,
                        timestamp: new Date().toISOString()
                    });
                });

                // Promise拒绝
                window.addEventListener('unhandledrejection', (e) => {
                    this.metrics.errors.push({
                        type: 'promise_rejection',
                        reason: e.reason,
                        timestamp: new Date().toISOString()
                    });
                });
            },

            startPeriodicReporting() {
                // 每分钟报告一次性能数据
                setInterval(() => {
                    this.reportPerformanceData();
                }, 60000);
            },

            reportPerformanceData() {
                const report = {
                    timestamp: new Date().toISOString(),
                    pageLoad: this.metrics.pageLoad,
                    userInteractions: this.metrics.userInteractions.slice(-50), // 最近50次交互
                    resourceTiming: this.metrics.resourceTiming.slice(-20), // 最近20个资源
                    errors: this.metrics.errors.slice(-10), // 最近10个错误
                    memory: this.getMemoryInfo(),
                    network: this.getNetworkInfo()
                };

                console.log('性能报告:', report);
                this.cleanupOldData();
            },

            getMemoryInfo() {
                if (performance.memory) {
                    return {
                        usedJSHeapSize: performance.memory.usedJSHeapSize,
                        totalJSHeapSize: performance.memory.totalJSHeapSize,
                        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
                    };
                }
                return null;
            },

            getNetworkInfo() {
                if (navigator.connection) {
                    return {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt
                    };
                }
                return null;
            },

            cleanupOldData() {
                const oneHourAgo = Date.now() - 60 * 60 * 1000;

                this.metrics.userInteractions = this.metrics.userInteractions.filter(
                    interaction => new Date(interaction.timestamp).getTime() > oneHourAgo
                );

                this.metrics.resourceTiming = this.metrics.resourceTiming.filter(
                    resource => new Date(resource.timestamp).getTime() > oneHourAgo
                );

                this.metrics.errors = this.metrics.errors.filter(
                    error => new Date(error.timestamp).getTime() > oneHourAgo
                );
            },

            getPerformanceReport() {
                return {
                    pageLoad: this.metrics.pageLoad,
                    averageInteractionTime: this.calculateAverageInteractionTime(),
                    errorRate: this.calculateErrorRate(),
                    resourceLoadTimes: this.calculateResourceLoadTimes(),
                    memoryUsage: this.getMemoryInfo(),
                    networkInfo: this.getNetworkInfo()
                };
            },

            calculateAverageInteractionTime() {
                if (this.metrics.userInteractions.length === 0) return 0;

                const totalTime = this.metrics.userInteractions.reduce((sum, interaction) => sum + interaction.duration, 0);
                return totalTime / this.metrics.userInteractions.length;
            },

            calculateErrorRate() {
                const totalInteractions = this.metrics.userInteractions.length;
                const totalErrors = this.metrics.errors.length;

                return totalInteractions > 0 ? (totalErrors / totalInteractions) * 100 : 0;
            },

            calculateResourceLoadTimes() {
                const resourceTypes = {};

                this.metrics.resourceTiming.forEach(resource => {
                    if (!resourceTypes[resource.type]) {
                        resourceTypes[resource.type] = [];
                    }
                    resourceTypes[resource.type].push(resource.duration);
                });

                const averages = {};
                Object.keys(resourceTypes).forEach(type => {
                    const times = resourceTypes[type];
                    averages[type] = times.reduce((sum, time) => sum + time, 0) / times.length;
                });

                return averages;
            }
        };

        // 缓存管理系统
        const CacheManager = {
            caches: new Map(),
            maxSize: 50 * 1024 * 1024, // 50MB
            currentSize: 0,

            init() {
                this.loadCacheFromStorage();
                this.setupCacheCleanup();
                console.log('缓存管理系统已初始化');
            },

            set(key, value, options = {}) {
                const {
                    ttl = 3600000, // 默认1小时
                    priority = 'normal',
                    size = this.estimateSize(value)
                } = options;

                const cacheEntry = {
                    key: key,
                    value: value,
                    size: size,
                    priority: priority,
                    createdAt: Date.now(),
                    expiresAt: Date.now() + ttl,
                    accessCount: 0,
                    lastAccessed: Date.now()
                };

                // 检查缓存大小限制
                if (this.currentSize + size > this.maxSize) {
                    this.evictCache(size);
                }

                this.caches.set(key, cacheEntry);
                this.currentSize += size;
                this.saveCacheToStorage();

                return cacheEntry;
            },

            get(key) {
                const entry = this.caches.get(key);

                if (!entry) {
                    return null;
                }

                // 检查是否过期
                if (Date.now() > entry.expiresAt) {
                    this.delete(key);
                    return null;
                }

                // 更新访问统计
                entry.accessCount++;
                entry.lastAccessed = Date.now();
                this.caches.set(key, entry);

                return entry.value;
            },

            delete(key) {
                const entry = this.caches.get(key);
                if (entry) {
                    this.currentSize -= entry.size;
                    this.caches.delete(key);
                    this.saveCacheToStorage();
                }
            },

            clear() {
                this.caches.clear();
                this.currentSize = 0;
                this.saveCacheToStorage();
            },

            has(key) {
                const entry = this.caches.get(key);
                return entry && Date.now() <= entry.expiresAt;
            },

            estimateSize(value) {
                const str = JSON.stringify(value);
                return new Blob([str]).size;
            },

            evictCache(requiredSize) {
                // 按优先级和访问时间排序
                const entries = Array.from(this.caches.values()).sort((a, b) => {
                    // 首先按优先级排序
                    const priorityOrder = { high: 3, normal: 2, low: 1 };
                    const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];

                    if (priorityDiff !== 0) {
                        return priorityDiff;
                    }

                    // 然后按最后访问时间排序
                    return a.lastAccessed - b.lastAccessed;
                });

                let freedSize = 0;
                const toDelete = [];

                for (const entry of entries) {
                    if (freedSize >= requiredSize) break;

                    toDelete.push(entry.key);
                    freedSize += entry.size;
                }

                toDelete.forEach(key => this.delete(key));
            },

            loadCacheFromStorage() {
                try {
                    const cached = localStorage.getItem('question_bank_cache');
                    if (cached) {
                        const data = JSON.parse(cached);
                        this.caches = new Map(data.entries);
                        this.currentSize = data.currentSize;
                    }
                } catch (error) {
                    console.warn('加载缓存失败:', error);
                    this.clear();
                }
            },

            saveCacheToStorage() {
                try {
                    const data = {
                        entries: Array.from(this.caches.entries()),
                        currentSize: this.currentSize,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('question_bank_cache', JSON.stringify(data));
                } catch (error) {
                    console.warn('保存缓存失败:', error);
                }
            },

            setupCacheCleanup() {
                // 每小时清理过期缓存
                setInterval(() => {
                    this.cleanupExpired();
                }, 60 * 60 * 1000);
            },

            cleanupExpired() {
                const now = Date.now();
                const toDelete = [];

                this.caches.forEach((entry, key) => {
                    if (now > entry.expiresAt) {
                        toDelete.push(key);
                    }
                });

                toDelete.forEach(key => this.delete(key));

                if (toDelete.length > 0) {
                    console.log(`清理了${toDelete.length} 个过期缓存项`);
                }
            },

            getCacheStats() {
                const stats = {
                    totalEntries: this.caches.size,
                    totalSize: this.currentSize,
                    maxSize: this.maxSize,
                    utilization: (this.currentSize / this.maxSize) * 100,
                    priorityDistribution: { high: 0, normal: 0, low: 0 },
                    expiredEntries: 0
                };

                const now = Date.now();
                this.caches.forEach(entry => {
                    stats.priorityDistribution[entry.priority]++;
                    if (now > entry.expiresAt) {
                        stats.expiredEntries++;
                    }
                });

                return stats;
            },

            // 预加载常用数据
            preloadData() {
                // 预加载用户偏好设置
                this.set('user_preferences', localStorage.getItem('userPreferences'), {
                    priority: 'high',
                    ttl: 24 * 60 * 60 * 1000 // 24小时
                });

                // 预加载搜索历史
                this.set('search_history', localStorage.getItem('search_history'), {
                    priority: 'normal',
                    ttl: 7 * 24 * 60 * 60 * 1000 // 7天
                });

                // 预加载分析数据
                this.set('analytics_data', localStorage.getItem('analytics_data'), {
                    priority: 'low',
                    ttl: 24 * 60 * 60 * 1000 // 24小时
                });
            }
        };

        // 增强的题目显示功能
        function showQuestionWithAdvancedFeatures() {
            const question = questionsData[currentQuestionIndex];
            if (!question) return;

            const container = document.getElementById('questionContainer');
            if (!container) return;

            // 使用缓存获取题目数据
            const cachedQuestion = CacheManager.get(`question_${question.id}`);
            const questionData = cachedQuestion || question;

            if (!cachedQuestion) {
                CacheManager.set(`question_${question.id}`, question, {
                    priority: 'high',
                    ttl: 30 * 60 * 1000 // 30分钟
                });
            }

            container.innerHTML = `
                <div class="question-header">
                    <div class="question-progress">
                        <span class="progress-text">题目 ${currentQuestionIndex + 1} / ${questionsData.length}</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${((currentQuestionIndex + 1) / questionsData.length) * 100}%"></div>
                        </div>
                    </div>
                    <div class="question-timer" id="questionTimer">
                        <i class="fas fa-clock"></i>
                        <span id="timerDisplay">00:00</span>
                    </div>
                    <div class="question-difficulty">
                        <span class="difficulty-badge ${questionData.difficulty}">${getDifficultyText(questionData.difficulty)}</span>
                    </div>
                </div>
                
                <div class="question-content">
                    <div class="question-text">
                        <h3>${questionData.question}</h3>
                    </div>
                    ${renderQuestionOptions(questionData)}
                </div>
                
                <div class="question-footer">
                    <div class="question-actions">
                        <button class="btn-control" onclick="previousQuestion()" id="prevBtn" ${currentQuestionIndex === 0 ? 'disabled' : ''}>
                            <i class="fas fa-chevron-left"></i>
                            上一题
                        </button>
                        <button class="btn-control" onclick="nextQuestion()" id="nextBtn" ${currentQuestionIndex === questionsData.length - 1 ? 'disabled' : ''}>
                            下一题
                            <i class="fas fa-chevron-right"></i>
                        </button>
                        <button class="btn-control secondary" onclick="showExplanation()" id="explainBtn" style="display: none;">
                            <i class="fas fa-lightbulb"></i>
                            查看解析
                        </button>
                    </div>
                    
                    <div class="question-tools">
                        <button class="tool-btn" onclick="openFullscreenQuestion(${currentQuestionIndex})" title="全屏查看">
                            <i class="fas fa-expand"></i>
                        </button>
                        <button class="tool-btn" onclick="showHint()" title="提示">
                            <i class="fas fa-lightbulb"></i>
                        </button>
                        <button class="tool-btn" onclick="bookmarkQuestion()" title="收藏">
                            <i class="fas fa-bookmark"></i>
                        </button>
                        <button class="tool-btn" onclick="reportQuestion()" title="报告">
                            <i class="fas fa-flag"></i>
                        </button>
                    </div>
                </div>
                
                <!-- 解析区域 -->
                <div class="explanation-area" id="explanationArea" style="display: none;">
                    <h4><i class="fas fa-lightbulb"></i> 题目解析</h4>
                    <div id="explanationText"></div>
                    <div class="explanation-meta">
                        <span class="difficulty">难度: ${getDifficultyText(questionData.difficulty)}</span>
                        <span class="points">分值: ${questionData.points || 10}</span>
                        <span class="estimated-time">预计时间: ${questionData.estimated_time || 60}秒</span>
                    </div>
                </div>
            `;

            startTimer();
            updateNavigationButtons();
        }

        // 获取难度文本
        function getDifficultyText(difficulty) {
            const difficultyMap = {
                'easy': '简单',
                'medium': '中等',
                'hard': '困难'
            };
            return difficultyMap[difficulty] || difficulty;
        }

        // 渲染题目选项
        function renderQuestionOptions(question) {
            switch (question.type) {
                case 'choice':
                    return `
                        <div class="question-options">
                            ${question.options.map((option, index) => `
                                <label class="option-item">
                                    <input type="radio" name="answer" value="${index}" ${isAnswered(index) ? 'checked' : ''}>
                                    <span class="option-text">${String.fromCharCode(65 + index)}. ${option}</span>
                                </label>
                            `).join('')}
                        </div>
                    `;
                case 'fill':
                    return `
                        <div class="question-answer">
                            <input type="text" class="form-control" placeholder="请输入答案" value="${getAnswer() || ''}">
                        </div>
                    `;
                case 'calculation':
                    return `
                        <div class="question-answer">
                            <input type="number" class="form-control" placeholder="请输入数值" value="${getAnswer() || ''}">
                            <span class="unit">${question.unit || ''}</span>
                        </div>
                    `;
                default:
                    return '<p>不支持的题目类型</p>';
            }
        }

        // 显示提示
        function showHint() {
            const question = questionsData[currentQuestionIndex];
            if (!question || !question.hint) {
                showNotification('暂无提示信息', 'info');
                return;
            }

            showNotification(`💡 提示: ${question.hint}`, 'info');
        }

        // 收藏题目
        function bookmarkQuestion() {
            const question = questionsData[currentQuestionIndex];
            if (!question) return;

            let bookmarks = JSON.parse(localStorage.getItem('question_bookmarks') || '[]');
            const existingIndex = bookmarks.findIndex(b => b.id === question.id);

            if (existingIndex >= 0) {
                bookmarks.splice(existingIndex, 1);
                showNotification('已取消收藏', 'info');
            } else {
                bookmarks.push({
                    id: question.id,
                    question: question.question,
                    timestamp: new Date().toISOString()
                });
                showNotification('已添加到收藏', 'success');
            }

            localStorage.setItem('question_bookmarks', JSON.stringify(bookmarks));
        }

        // 报告题目
        function reportQuestion() {
            const question = questionsData[currentQuestionIndex];
            if (!question) return;

            const reportReason = prompt('请选择报告原因:\n1. 题目有误\n2. 答案错误\n3. 解析不清\n4. 其他');
            if (!reportReason) return;

            let reports = JSON.parse(localStorage.getItem('question_reports') || '[]');
            reports.push({
                questionId: question.id,
                reason: reportReason,
                timestamp: new Date().toISOString()
            });

            localStorage.setItem('question_reports', JSON.stringify(reports));
            showNotification('感谢您的反馈！', 'success');
        }

        // 初始化系统
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化性能监控
            PerformanceMonitor.init();
            
            // 初始化缓存管理
            CacheManager.init();
            
            // 预加载数据
            CacheManager.preloadData();
            
            // 初始化高级题库系统
            quizSystem = new AdvancedQuizSystem();
            
            // 初始化错题本和收藏显示
            if (quizSystem) {
                quizSystem.updateWrongQuestionsDisplay();
                quizSystem.updateFavoritesDisplay();
            }
            
            // 加载本地存储的题目
            loadQuestionsFromLocalStorage();
            
            // 显示第一题
            showQuestionWithAdvancedFeatures();
            
            // 尝试加载练习进度
            if (loadPracticeProgress()) {
                showQuestionWithAdvancedFeatures();
                showNotification('📚 已恢复上次练习进度', 'info');
            }
            
            // 显示推荐题目
            showRecommendedQuestions();
            
            console.log('题库模块已完全初始化');
        });
        
        console.log('❓ 题库练习模块已加载');

        // 智能题目推荐
        function getRecommendedQuestions() {
            const userLearningData = JSON.parse(localStorage.getItem('userLearningData') || '{}');
            const userProgress = userLearningData.completedQuestions || 0;
            const userLevel = userProgress < 10 ? 'beginner' : userProgress < 30 ? 'intermediate' : 'advanced';
            
            // 获取用户错误率较高的知识点
            const userStats = JSON.parse(localStorage.getItem('userStats') || '{}');
            const weakTopics = Object.entries(userStats)
                .filter(([topic, stats]) => stats.wrong > stats.correct)
                .map(([topic]) => topic)
                .slice(0, 3);
            
            // 根据用户水平推荐题目
            let recommendedQuestions = [];
            
            if (userLevel === 'beginner') {
                // 初学者推荐基础题目
                recommendedQuestions = questionsData.filter(q => 
                    q.difficulty === 'easy' || q.difficulty === '简单' ||
                    q.category.includes('基础') || q.category.includes('概念')
                ).slice(0, 5);
            } else if (userLevel === 'intermediate') {
                // 中等水平推荐综合题目
                recommendedQuestions = questionsData.filter(q => 
                    q.difficulty === 'medium' || q.difficulty === '中等' ||
                    q.category.includes('应用') || q.category.includes('计算')
                ).slice(0, 5);
            } else {
                // 高级水平推荐复杂题目
                recommendedQuestions = questionsData.filter(q => 
                    q.difficulty === 'hard' || q.difficulty === '困难' ||
                    q.category.includes('综合') || q.category.includes('分析')
                ).slice(0, 5);
            }
            
            // 如果有薄弱知识点，优先推荐相关题目
            if (weakTopics.length > 0) {
                const weakTopicQuestions = questionsData.filter(q => 
                    weakTopics.some(topic => 
                        q.text.includes(topic) || 
                        q.category.includes(topic) ||
                        (q.learningPoints && q.learningPoints.some(point => point.includes(topic)))
                    )
                ).slice(0, 3);
                
                recommendedQuestions = [...weakTopicQuestions, ...recommendedQuestions].slice(0, 5);
            }
            
            return recommendedQuestions;
        }
        
        // 显示推荐题目
        function showRecommendedQuestions() {
            const recommendedQuestions = getRecommendedQuestions();
            const container = document.getElementById('recommendedQuestions');
            if (!container || recommendedQuestions.length === 0) return;
            
            container.innerHTML = `
                <div class="recommendation-section">
                    <h3>🎯 智能推荐题目</h3>
                    <p style="font-size: 0.9em; opacity: 0.8; margin-bottom: 15px;">
                        根据您的学习进度和薄弱环节推荐
                    </p>
                    <div class="recommended-list">
                        ${recommendedQuestions.map((q, index) => `
                            <div class="recommended-item" onclick="startPracticeWithQuestion('${q.id}')">
                                <div class="item-header">
                                    <span class="item-number">${index + 1}</span>
                                    <span class="item-difficulty ${q.difficulty === 'easy' || q.difficulty === '简单' ? 'easy' : q.difficulty === 'hard' || q.difficulty === '困难' ? 'hard' : 'medium'}">
                                        ${q.difficulty}
                                    </span>
                                </div>
                                <div class="item-content">
                                    ${q.text.replace(/^🤖 (AI生成题目|备用题目)\d*：/, '')}
                                </div>
                                <div class="item-category">
                                    ${q.category}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        // 从指定题目开始练习
        function startPracticeWithQuestion(questionId) {
            const questionIndex = questionsData.findIndex(q => q.id === questionId);
            if (questionIndex !== -1) {
                currentQuestionIndex = questionIndex;
                showQuestion();
                showNotification('🎯 已跳转到推荐题目', 'success');
            }
        }
        
        // 更新用户统计
        function updateUserStats(question, isCorrect) {
            const userStats = JSON.parse(localStorage.getItem('userStats') || '{}');
            
            // 提取题目中的关键词作为主题
            const topics = extractTopics(question.text);
            
            topics.forEach(topic => {
                if (!userStats[topic]) {
                    userStats[topic] = { correct: 0, wrong: 0, total: 0 };
                }
                
                userStats[topic].total++;
                if (isCorrect) {
                    userStats[topic].correct++;
                } else {
                    userStats[topic].wrong++;
                }
            });
            
            localStorage.setItem('userStats', JSON.stringify(userStats));
        }
        
        // 提取题目主题
        function extractTopics(questionText) {
            const topicKeywords = [
                '伯努利', '雷诺', '边界层', '层流', '湍流', '流体静力学', 
                '压强', '速度', '流量', '粘度', '密度', '浮力', '阻力',
                '管道', '泵', '涡轮', '阀门', '喷嘴', '扩散器'
            ];
            
            return topicKeywords.filter(keyword => questionText.includes(keyword));
        }

        // 全屏题目查看功能
        let fullscreenMode = false;
        let fullscreenCurrentQuestionIndex = 0;
        let fullscreenSelectedAnswer = null;
        let fullscreenAnswered = false;
        
        // 打开全屏题目查看
        function openFullscreenQuestion(questionIndex = currentQuestionIndex) {
            if (questionsData.length === 0) {
                showNotification('没有可用的题目', 'error');
                return;
            }
            
            fullscreenMode = true;
            fullscreenCurrentQuestionIndex = questionIndex;
            fullscreenSelectedAnswer = null;
            fullscreenAnswered = false;
            
            const overlay = document.getElementById('fullscreenOverlay');
            overlay.style.display = 'block';
            
            // 禁用页面滚动
            document.body.style.overflow = 'hidden';
            
            showFullscreenQuestion();
            updateFullscreenProgress();
            updateFullscreenNavigation();
        }
        
        // 关闭全屏题目查看
        function closeFullscreen() {
            const overlay = document.getElementById('fullscreenOverlay');
            overlay.style.display = 'none';
            
            // 恢复页面滚动
            document.body.style.overflow = '';
            
            fullscreenMode = false;
            
            // 同步普通模式的进度
            if (fullscreenCurrentQuestionIndex !== currentQuestionIndex) {
                currentQuestionIndex = fullscreenCurrentQuestionIndex;
                showQuestion();
            }
            
            // 保存进度
            savePracticeProgress();
        }
        
        // 显示全屏题目
        function showFullscreenQuestion() {
            const question = questionsData[fullscreenCurrentQuestionIndex];
            if (!question) return;
            
            // 显示题目内容
            const questionContent = document.getElementById('fullscreenQuestionContent');
            questionContent.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <span style="background: var(--ocean-light); color: white; padding: 4px 8px; border-radius: 8px; font-size: 0.8rem;">
                        ${question.category || '未知分类'}
                    </span>
                    <span style="background: ${getDifficultyColor(question.difficulty)}; color: white; padding: 4px 8px; border-radius: 8px; font-size: 0.8rem; margin-left: 8px;">
                        ${question.difficulty || '中等'}
                    </span>
                </div>
                <div style="font-size: 1.1rem; line-height: 1.6;">
                    ${question.text.replace(/^🤖 (AI生成题目|备用题目)\d*：/, '')}
                </div>
            `;
            
            // 显示选项
            const optionsContainer = document.getElementById('fullscreenOptions');
            optionsContainer.innerHTML = question.options.map((option, index) => `
                <div class="fullscreen-option ${fullscreenSelectedAnswer === index ? 'selected' : ''} ${fullscreenAnswered ? (index === question.correct ? 'correct' : (fullscreenSelectedAnswer === index && fullscreenSelectedAnswer !== question.correct ? 'wrong' : '')) : ''}" 
                     onclick="selectFullscreenOption(${index})">
                    <div class="option-label">${String.fromCharCode(65 + index)}</div>
                    <div style="flex: 1;">${option}</div>
                </div>
            `).join('');
            
            // 显示解析
            const explanationContent = document.getElementById('fullscreenExplanationContent');
            explanationContent.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong>正确答案：</strong> ${String.fromCharCode(65 + question.correct)}
                </div>
                <div style="line-height: 1.5;">
                    ${question.explanation || '暂无解析'}
                </div>
            `;
            
            // 更新按钮状态
            updateFullscreenButtons();
        }
        
        // 选择全屏选项
        function selectFullscreenOption(index) {
            if (fullscreenAnswered) return;
            
            fullscreenSelectedAnswer = index;
            
            // 更新选项样式
            const options = document.querySelectorAll('.fullscreen-option');
            options.forEach((option, i) => {
                option.classList.remove('selected');
                if (i === index) {
                    option.classList.add('selected');
                }
            });
            
            updateFullscreenButtons();
        }
        
        // 提交全屏答案
        function submitFullscreenAnswer() {
            if (fullscreenSelectedAnswer === null) {
                showNotification('请先选择一个答案', 'error');
                return;
            }
            
            if (fullscreenAnswered) return;
            
            const question = questionsData[fullscreenCurrentQuestionIndex];
            const isCorrect = fullscreenSelectedAnswer === question.correct;
            
            fullscreenAnswered = true;
            
            // 更新选项样式显示正确答案
            const options = document.querySelectorAll('.fullscreen-option');
            options.forEach((option, index) => {
                if (index === question.correct) {
                    option.classList.add('correct');
                } else if (index === fullscreenSelectedAnswer && !isCorrect) {
                    option.classList.add('wrong');
                }
            });
            
            // 更新统计
            updateUserStats(question, isCorrect);
            
            // 更新学习进度
            updateLearningProgress(isCorrect);
            
            // 如果答错了，添加到错题本
            if (!isCorrect) {
                addToWrongQuestions(question);
            }
            
            // 更新按钮状态
            updateFullscreenButtons();
            
            // 显示结果通知
            showNotification(isCorrect ? '🎉 回答正确！' : '❌ 回答错误，请查看解析', isCorrect ? 'success' : 'error');
        }
        
        // 切换全屏解析显示
        function toggleFullscreenExplanation() {
            const explanation = document.getElementById('fullscreenExplanation');
            const explanationBtn = document.getElementById('explanationBtn');
            
            if (explanation.style.display === 'none' || explanation.style.display === '') {
                explanation.style.display = 'block';
                explanationBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 隐藏解析';
            } else {
                explanation.style.display = 'none';
                explanationBtn.innerHTML = '<i class="fas fa-lightbulb"></i> 查看解析';
            }
        }
        
        // 切换全屏收藏
        function toggleFullscreenFavorite() {
            const question = questionsData[fullscreenCurrentQuestionIndex];
            const favoriteBtn = document.getElementById('favoriteFullscreenBtn');
            
            const favorites = JSON.parse(localStorage.getItem('favoriteQuestions') || '[]');
            const isFavorited = favorites.some(f => f.id === question.id);
            
            if (isFavorited) {
                // 取消收藏
                const newFavorites = favorites.filter(f => f.id !== question.id);
                localStorage.setItem('favoriteQuestions', JSON.stringify(newFavorites));
                favoriteBtn.innerHTML = '<i class="fas fa-heart"></i> 收藏题目';
                showNotification('已取消收藏', 'info');
            } else {
                // 添加收藏
                favorites.push(question);
                localStorage.setItem('favoriteQuestions', JSON.stringify(favorites));
                favoriteBtn.innerHTML = '<i class="fas fa-heart" style="color: #e74c3c;"></i> 已收藏';
                showNotification('已添加到收藏', 'success');
            }
        }
        
        // 上一题（全屏）
        function previousFullscreenQuestion() {
            if (fullscreenCurrentQuestionIndex > 0) {
                fullscreenCurrentQuestionIndex--;
                fullscreenSelectedAnswer = null;
                fullscreenAnswered = false;
                showFullscreenQuestion();
                updateFullscreenProgress();
                updateFullscreenNavigation();
            }
        }
        
        // 下一题（全屏）
        function nextFullscreenQuestion() {
            if (fullscreenCurrentQuestionIndex < questionsData.length - 1) {
                fullscreenCurrentQuestionIndex++;
                fullscreenSelectedAnswer = null;
                fullscreenAnswered = false;
                showFullscreenQuestion();
                updateFullscreenProgress();
                updateFullscreenNavigation();
            }
        }
        
        // 更新全屏进度显示
        function updateFullscreenProgress() {
            const progress = document.getElementById('fullscreenProgress');
            progress.textContent = `第 ${fullscreenCurrentQuestionIndex + 1} 题 / 共 ${questionsData.length} 题`;
        }
        
        // 更新全屏导航按钮
        function updateFullscreenNavigation() {
            const prevBtn = document.getElementById('prevFullscreenBtn');
            const nextBtn = document.getElementById('nextFullscreenBtn');
            
            prevBtn.disabled = fullscreenCurrentQuestionIndex === 0;
            nextBtn.disabled = fullscreenCurrentQuestionIndex === questionsData.length - 1;
        }
        
        // 更新全屏按钮状态
        function updateFullscreenButtons() {
            const submitBtn = document.getElementById('submitFullscreenBtn');
            const explanationBtn = document.getElementById('explanationBtn');
            const favoriteBtn = document.getElementById('favoriteFullscreenBtn');
            
            // 提交按钮状态
            if (fullscreenAnswered) {
                submitBtn.innerHTML = '<i class="fas fa-check"></i> 已提交';
                submitBtn.disabled = true;
            } else {
                submitBtn.innerHTML = '<i class="fas fa-check"></i> 提交答案';
                submitBtn.disabled = fullscreenSelectedAnswer === null;
            }
            
            // 解析按钮状态
            if (fullscreenAnswered) {
                explanationBtn.innerHTML = '<i class="fas fa-lightbulb"></i> 查看解析';
                explanationBtn.disabled = false;
            } else {
                explanationBtn.innerHTML = '<i class="fas fa-lightbulb"></i> 提交后查看解析';
                explanationBtn.disabled = true;
            }
            
            // 收藏按钮状态
            const question = questionsData[fullscreenCurrentQuestionIndex];
            const favorites = JSON.parse(localStorage.getItem('favoriteQuestions') || '[]');
            const isFavorited = favorites.some(f => f.id === question.id);
            
            if (isFavorited) {
                favoriteBtn.innerHTML = '<i class="fas fa-heart" style="color: #e74c3c;"></i> 已收藏';
            } else {
                favoriteBtn.innerHTML = '<i class="fas fa-heart"></i> 收藏题目';
            }
        }
        
        // 获取难度颜色
        function getDifficultyColor(difficulty) {
            switch (difficulty) {
                case 'easy':
                case '简单':
                    return '#2ecc71';
                case 'hard':
                case '困难':
                    return '#e74c3c';
                default:
                    return '#f39c12';
            }
        }
        
        // 保存练习进度
        function savePracticeProgress() {
            const progress = {
                currentIndex: fullscreenMode ? fullscreenCurrentQuestionIndex : currentQuestionIndex,
                totalQuestions: questionsData.length,
                timestamp: Date.now()
            };
            
            localStorage.setItem('practiceProgress', JSON.stringify(progress));
        }
        
        // 加载练习进度
        function loadPracticeProgress() {
            const savedProgress = localStorage.getItem('practiceProgress');
            if (savedProgress) {
                const progress = JSON.parse(savedProgress);
                const timeDiff = Date.now() - progress.timestamp;
                
                // 如果进度保存时间不超过1小时，则恢复进度
                if (timeDiff < 3600000 && progress.currentIndex < questionsData.length) {
                    currentQuestionIndex = progress.currentIndex;
                    return true;
                }
            }
            return false;
        }

        // 键盘快捷键支持
        document.addEventListener('keydown', function(event) {
            // 全屏模式下的快捷键
            if (fullscreenMode) {
                switch(event.key) {
                    case 'Escape':
                        event.preventDefault();
                        closeFullscreen();
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        previousFullscreenQuestion();
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        nextFullscreenQuestion();
                        break;
                    case 'Enter':
                        event.preventDefault();
                        if (!fullscreenAnswered) {
                            submitFullscreenAnswer();
                        }
                        break;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                        event.preventDefault();
                        const optionIndex = parseInt(event.key) - 1;
                        if (optionIndex >= 0 && optionIndex < 4 && !fullscreenAnswered) {
                            selectFullscreenOption(optionIndex);
                        }
                        break;
                    case 'e':
                    case 'E':
                        event.preventDefault();
                        if (fullscreenAnswered) {
                            toggleFullscreenExplanation();
                        }
                        break;
                    case 'f':
                    case 'F':
                        event.preventDefault();
                        toggleFullscreenFavorite();
                        break;
                }
            } else {
                // 普通模式下的快捷键
                switch(event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        previousQuestion();
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        nextQuestion();
                        break;
                    case 'Enter':
                        event.preventDefault();
                        submitAnswer();
                        break;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                        event.preventDefault();
                        const optionIndex = parseInt(event.key) - 1;
                        if (optionIndex >= 0 && optionIndex < 4) {
                            selectOption(optionIndex);
                        }
                        break;
                    case 'f':
                    case 'F':
                        event.preventDefault();
                        openFullscreenQuestion();
                        break;
                }
            }
        });
        
        // 添加键盘快捷键提示
        function showKeyboardShortcuts() {
            const shortcuts = fullscreenMode ? {
                'ESC': '关闭全屏',
                '←/→': '上一题/下一题',
                'Enter': '提交答案',
                '1-4': '选择选项',
                'E': '查看解析',
                'F': '收藏题目'
            } : {
                '←/→': '上一题/下一题',
                'Enter': '提交答案',
                '1-4': '选择选项',
                'F': '全屏查看'
            };
            
            const shortcutText = Object.entries(shortcuts)
                .map(([key, desc]) => `${key}: ${desc}`)
                .join(' | ');
            
            showNotification(`⌨️ 快捷键: ${shortcutText}`, 'info', 5000);
        }
    </script>
</body>
</html> 