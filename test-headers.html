<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTPå¤´éƒ¨æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-result {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .pass { border-left: 4px solid #4caf50; }
        .fail { border-left: 4px solid #f44336; }
        .pending { border-left: 4px solid #ff9800; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto; }
        button { background: #1976d2; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #1565c0; }
    </style>
</head>
<body>
    <h1>ğŸ” HTTPå¤´éƒ¨å’Œæ€§èƒ½æµ‹è¯•</h1>
    
    <div class="test-result pending" id="swStatus">
        <h3>Service WorkerçŠ¶æ€</h3>
        <p id="swInfo">æ£€æŸ¥ä¸­...</p>
    </div>
    
    <div class="test-result pending" id="headerTest">
        <h3>HTTPå®‰å…¨å¤´éƒ¨æµ‹è¯•</h3>
        <p id="headerInfo">æ£€æŸ¥ä¸­...</p>
        <pre id="headerDetails"></pre>
    </div>
    
    <div class="test-result pending" id="cacheTest">
        <h3>ç¼“å­˜ç­–ç•¥æµ‹è¯•</h3>
        <p id="cacheInfo">æ£€æŸ¥ä¸­...</p>
        <pre id="cacheDetails"></pre>
    </div>
    
    <div class="test-result pending" id="fontTest">
        <h3>å­—ä½“æ–‡ä»¶Content-Typeæµ‹è¯•</h3>
        <p id="fontInfo">æ£€æŸ¥ä¸­...</p>
        <pre id="fontDetails"></pre>
    </div>
    
    <div style="text-align: center; margin-top: 30px;">
        <button onclick="runAllTests()">ğŸ”„ é‡æ–°æµ‹è¯•</button>
        <button onclick="clearCache()">ğŸ—‘ï¸ æ¸…ç†ç¼“å­˜</button>
        <button onclick="window.location.href='/fluid_dynamic_2.html'">ğŸ  è¿”å›ä¸»é¡µ</button>
    </div>

    <script>
        function updateStatus(elementId, status, message, details = '') {
            const element = document.getElementById(elementId);
            element.className = `test-result ${status}`;
            document.getElementById(elementId.replace('Test', 'Info')).textContent = message;
            
            const detailsElement = document.getElementById(elementId.replace('Test', 'Details'));
            if (detailsElement && details) {
                detailsElement.textContent = details;
            }
        }

        async function checkServiceWorker() {
            try {
                if ('serviceWorker' in navigator) {
                    const registration = await navigator.serviceWorker.getRegistration();
                    if (registration && registration.active) {
                        updateStatus('swStatus', 'pass', 'âœ… Service Workerå·²æ¿€æ´»');
                        return true;
                    } else {
                        updateStatus('swStatus', 'fail', 'âŒ Service Workeræœªæ¿€æ´»');
                        return false;
                    }
                } else {
                    updateStatus('swStatus', 'fail', 'âŒ æµè§ˆå™¨ä¸æ”¯æŒService Worker');
                    return false;
                }
            } catch (error) {
                updateStatus('swStatus', 'fail', `âŒ Service Workeræ£€æŸ¥å¤±è´¥: ${error.message}`);
                return false;
            }
        }

        async function checkHeaders() {
            try {
                const response = await fetch('/manifest.json', { 
                    method: 'HEAD',
                    cache: 'no-cache'
                });

                const headers = {};
                response.headers.forEach((value, key) => {
                    headers[key] = value;
                });

                const requiredHeaders = [
                    'x-content-type-options',
                    'x-frame-options', 
                    'x-xss-protection',
                    'referrer-policy'
                ];

                const missing = requiredHeaders.filter(header => !headers[header]);
                
                if (missing.length === 0) {
                    updateStatus('headerTest', 'pass', 'âœ… æ‰€æœ‰å®‰å…¨å¤´éƒ¨å·²è®¾ç½®', JSON.stringify(headers, null, 2));
                } else {
                    updateStatus('headerTest', 'fail', `âŒ ç¼ºå°‘å¤´éƒ¨: ${missing.join(', ')}`, JSON.stringify(headers, null, 2));
                }
            } catch (error) {
                updateStatus('headerTest', 'fail', `âŒ å¤´éƒ¨æ£€æŸ¥å¤±è´¥: ${error.message}`);
            }
        }

        async function checkCache() {
            try {
                // æµ‹è¯•HTMLæ–‡ä»¶ç¼“å­˜
                const htmlResponse = await fetch('/test-headers.html', { cache: 'no-cache' });
                const htmlCache = htmlResponse.headers.get('cache-control');
                
                // æµ‹è¯•é™æ€èµ„æºç¼“å­˜
                const manifestResponse = await fetch('/manifest.json', { cache: 'no-cache' });
                const manifestCache = manifestResponse.headers.get('cache-control');

                const cacheInfo = {
                    'HTMLç¼“å­˜ç­–ç•¥': htmlCache || 'æœªè®¾ç½®',
                    'é™æ€èµ„æºç¼“å­˜': manifestCache || 'æœªè®¾ç½®'
                };

                const hasCorrectCache = htmlCache && htmlCache.includes('no-cache') && 
                                      manifestCache && manifestCache.includes('max-age=31536000');

                if (hasCorrectCache) {
                    updateStatus('cacheTest', 'pass', 'âœ… ç¼“å­˜ç­–ç•¥æ­£ç¡®', JSON.stringify(cacheInfo, null, 2));
                } else {
                    updateStatus('cacheTest', 'fail', 'âŒ ç¼“å­˜ç­–ç•¥éœ€è¦ä¼˜åŒ–', JSON.stringify(cacheInfo, null, 2));
                }
            } catch (error) {
                updateStatus('cacheTest', 'fail', `âŒ ç¼“å­˜æ£€æŸ¥å¤±è´¥: ${error.message}`);
            }
        }

        async function checkFontTypes() {
            try {
                // åˆ›å»ºä¸€ä¸ªæµ‹è¯•å­—ä½“URLï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                const testUrls = [
                    '/fonts/test.woff2',
                    '/static/fonts/test.woff2', 
                    '/assets/fonts/test.woff2'
                ];

                let fontResult = 'æ²¡æœ‰æ‰¾åˆ°å­—ä½“æ–‡ä»¶è¿›è¡Œæµ‹è¯•';
                
                for (const url of testUrls) {
                    try {
                        const response = await fetch(url, { method: 'HEAD' });
                        if (response.ok) {
                            const contentType = response.headers.get('content-type');
                            fontResult = `å­—ä½“æ–‡ä»¶Content-Type: ${contentType}`;
                            
                            if (contentType === 'font/woff2') {
                                updateStatus('fontTest', 'pass', 'âœ… å­—ä½“Content-Typeæ­£ç¡®', fontResult);
                            } else {
                                updateStatus('fontTest', 'fail', 'âŒ å­—ä½“Content-Typeéœ€è¦ä¿®å¤', fontResult);
                            }
                            return;
                        }
                    } catch (e) {
                        // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªURL
                    }
                }
                
                updateStatus('fontTest', 'pending', 'â³ æœªæ‰¾åˆ°å­—ä½“æ–‡ä»¶', fontResult);
            } catch (error) {
                updateStatus('fontTest', 'fail', `âŒ å­—ä½“æ£€æŸ¥å¤±è´¥: ${error.message}`);
            }
        }

        async function runAllTests() {
            console.log('ğŸ” å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯•...');
            
            await checkServiceWorker();
            await checkHeaders();
            await checkCache();
            await checkFontTypes();
            
            console.log('âœ… æ‰€æœ‰æµ‹è¯•å®Œæˆ');
        }

        async function clearCache() {
            if ('caches' in window) {
                const cacheNames = await caches.keys();
                await Promise.all(cacheNames.map(name => caches.delete(name)));
                console.log('ğŸ—‘ï¸ ç¼“å­˜å·²æ¸…ç†');
                alert('ç¼“å­˜å·²æ¸…ç†ï¼Œå»ºè®®åˆ·æ–°é¡µé¢');
            }
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¿è¡Œæµ‹è¯•
        window.addEventListener('load', () => {
            setTimeout(runAllTests, 1000);
        });
    </script>
</body>
</html>